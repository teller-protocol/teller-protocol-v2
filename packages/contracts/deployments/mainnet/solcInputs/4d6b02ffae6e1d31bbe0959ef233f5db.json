{
  "language": "Solidity",
  "sources": {
    "contracts/EAS/TellerAS.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../Types.sol\";\nimport \"../interfaces/IEAS.sol\";\nimport \"../interfaces/IASRegistry.sol\";\n\n/**\n * @title TellerAS - Teller Attestation Service - based on EAS - Ethereum Attestation Service\n */\ncontract TellerAS is IEAS {\n    error AccessDenied();\n    error AlreadyRevoked();\n    error InvalidAttestation();\n    error InvalidExpirationTime();\n    error InvalidOffset();\n    error InvalidRegistry();\n    error InvalidSchema();\n    error InvalidVerifier();\n    error NotFound();\n    error NotPayable();\n\n    string public constant VERSION = \"0.8\";\n\n    // A terminator used when concatenating and hashing multiple fields.\n    string private constant HASH_TERMINATOR = \"@\";\n\n    // The AS global registry.\n    IASRegistry private immutable _asRegistry;\n\n    // The EIP712 verifier used to verify signed attestations.\n    IEASEIP712Verifier private immutable _eip712Verifier;\n\n    // A mapping between attestations and their related attestations.\n    mapping(bytes32 => bytes32[]) private _relatedAttestations;\n\n    // A mapping between an account and its received attestations.\n    mapping(address => mapping(bytes32 => bytes32[]))\n        private _receivedAttestations;\n\n    // A mapping between an account and its sent attestations.\n    mapping(address => mapping(bytes32 => bytes32[])) private _sentAttestations;\n\n    // A mapping between a schema and its attestations.\n    mapping(bytes32 => bytes32[]) private _schemaAttestations;\n\n    // The global mapping between attestations and their UUIDs.\n    mapping(bytes32 => Attestation) private _db;\n\n    // The global counter for the total number of attestations.\n    uint256 private _attestationsCount;\n\n    bytes32 private _lastUUID;\n\n    /**\n     * @dev Creates a new EAS instance.\n     *\n     * @param registry The address of the global AS registry.\n     * @param verifier The address of the EIP712 verifier.\n     */\n    constructor(IASRegistry registry, IEASEIP712Verifier verifier) {\n        if (address(registry) == address(0x0)) {\n            revert InvalidRegistry();\n        }\n\n        if (address(verifier) == address(0x0)) {\n            revert InvalidVerifier();\n        }\n\n        _asRegistry = registry;\n        _eip712Verifier = verifier;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getASRegistry() external view override returns (IASRegistry) {\n        return _asRegistry;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getEIP712Verifier()\n        external\n        view\n        override\n        returns (IEASEIP712Verifier)\n    {\n        return _eip712Verifier;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getAttestationsCount() external view override returns (uint256) {\n        return _attestationsCount;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function attest(\n        address recipient,\n        bytes32 schema,\n        uint256 expirationTime,\n        bytes32 refUUID,\n        bytes calldata data\n    ) public payable virtual override returns (bytes32) {\n        return\n            _attest(\n                recipient,\n                schema,\n                expirationTime,\n                refUUID,\n                data,\n                msg.sender\n            );\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function attestByDelegation(\n        address recipient,\n        bytes32 schema,\n        uint256 expirationTime,\n        bytes32 refUUID,\n        bytes calldata data,\n        address attester,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable virtual override returns (bytes32) {\n        _eip712Verifier.attest(\n            recipient,\n            schema,\n            expirationTime,\n            refUUID,\n            data,\n            attester,\n            v,\n            r,\n            s\n        );\n\n        return\n            _attest(recipient, schema, expirationTime, refUUID, data, attester);\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function revoke(bytes32 uuid) public virtual override {\n        return _revoke(uuid, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function revokeByDelegation(\n        bytes32 uuid,\n        address attester,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        _eip712Verifier.revoke(uuid, attester, v, r, s);\n\n        _revoke(uuid, attester);\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getAttestation(bytes32 uuid)\n        external\n        view\n        override\n        returns (Attestation memory)\n    {\n        return _db[uuid];\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function isAttestationValid(bytes32 uuid)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _db[uuid].uuid != 0;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function isAttestationActive(bytes32 uuid)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            isAttestationValid(uuid) &&\n            _db[uuid].expirationTime >= block.timestamp &&\n            _db[uuid].revocationTime == 0;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getReceivedAttestationUUIDs(\n        address recipient,\n        bytes32 schema,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) external view override returns (bytes32[] memory) {\n        return\n            _sliceUUIDs(\n                _receivedAttestations[recipient][schema],\n                start,\n                length,\n                reverseOrder\n            );\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getReceivedAttestationUUIDsCount(address recipient, bytes32 schema)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _receivedAttestations[recipient][schema].length;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getSentAttestationUUIDs(\n        address attester,\n        bytes32 schema,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) external view override returns (bytes32[] memory) {\n        return\n            _sliceUUIDs(\n                _sentAttestations[attester][schema],\n                start,\n                length,\n                reverseOrder\n            );\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getSentAttestationUUIDsCount(address recipient, bytes32 schema)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _sentAttestations[recipient][schema].length;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getRelatedAttestationUUIDs(\n        bytes32 uuid,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) external view override returns (bytes32[] memory) {\n        return\n            _sliceUUIDs(\n                _relatedAttestations[uuid],\n                start,\n                length,\n                reverseOrder\n            );\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getRelatedAttestationUUIDsCount(bytes32 uuid)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _relatedAttestations[uuid].length;\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getSchemaAttestationUUIDs(\n        bytes32 schema,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) external view override returns (bytes32[] memory) {\n        return\n            _sliceUUIDs(\n                _schemaAttestations[schema],\n                start,\n                length,\n                reverseOrder\n            );\n    }\n\n    /**\n     * @inheritdoc IEAS\n     */\n    function getSchemaAttestationUUIDsCount(bytes32 schema)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _schemaAttestations[schema].length;\n    }\n\n    /**\n     * @dev Attests to a specific AS.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param schema The UUID of the AS.\n     * @param expirationTime The expiration time of the attestation.\n     * @param refUUID An optional related attestation's UUID.\n     * @param data Additional custom data.\n     * @param attester The attesting account.\n     *\n     * @return The UUID of the new attestation.\n     */\n    function _attest(\n        address recipient,\n        bytes32 schema,\n        uint256 expirationTime,\n        bytes32 refUUID,\n        bytes calldata data,\n        address attester\n    ) private returns (bytes32) {\n        if (expirationTime <= block.timestamp) {\n            revert InvalidExpirationTime();\n        }\n\n        IASRegistry.ASRecord memory asRecord = _asRegistry.getAS(schema);\n        if (asRecord.uuid == EMPTY_UUID) {\n            revert InvalidSchema();\n        }\n\n        IASResolver resolver = asRecord.resolver;\n        if (address(resolver) != address(0x0)) {\n            if (msg.value != 0 && !resolver.isPayable()) {\n                revert NotPayable();\n            }\n\n            if (\n                !resolver.resolve{ value: msg.value }(\n                    recipient,\n                    asRecord.schema,\n                    data,\n                    expirationTime,\n                    attester\n                )\n            ) {\n                revert InvalidAttestation();\n            }\n        }\n\n        Attestation memory attestation = Attestation({\n            uuid: EMPTY_UUID,\n            schema: schema,\n            recipient: recipient,\n            attester: attester,\n            time: block.timestamp,\n            expirationTime: expirationTime,\n            revocationTime: 0,\n            refUUID: refUUID,\n            data: data\n        });\n\n        _lastUUID = _getUUID(attestation);\n        attestation.uuid = _lastUUID;\n\n        _receivedAttestations[recipient][schema].push(_lastUUID);\n        _sentAttestations[attester][schema].push(_lastUUID);\n        _schemaAttestations[schema].push(_lastUUID);\n\n        _db[_lastUUID] = attestation;\n        _attestationsCount++;\n\n        if (refUUID != 0) {\n            if (!isAttestationValid(refUUID)) {\n                revert NotFound();\n            }\n\n            _relatedAttestations[refUUID].push(_lastUUID);\n        }\n\n        emit Attested(recipient, attester, _lastUUID, schema);\n\n        return _lastUUID;\n    }\n\n    function getLastUUID() external view returns (bytes32) {\n        return _lastUUID;\n    }\n\n    /**\n     * @dev Revokes an existing attestation to a specific AS.\n     *\n     * @param uuid The UUID of the attestation to revoke.\n     * @param attester The attesting account.\n     */\n    function _revoke(bytes32 uuid, address attester) private {\n        Attestation storage attestation = _db[uuid];\n        if (attestation.uuid == EMPTY_UUID) {\n            revert NotFound();\n        }\n\n        if (attestation.attester != attester) {\n            revert AccessDenied();\n        }\n\n        if (attestation.revocationTime != 0) {\n            revert AlreadyRevoked();\n        }\n\n        attestation.revocationTime = block.timestamp;\n\n        emit Revoked(attestation.recipient, attester, uuid, attestation.schema);\n    }\n\n    /**\n     * @dev Calculates a UUID for a given attestation.\n     *\n     * @param attestation The input attestation.\n     *\n     * @return Attestation UUID.\n     */\n    function _getUUID(Attestation memory attestation)\n        private\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    attestation.schema,\n                    attestation.recipient,\n                    attestation.attester,\n                    attestation.time,\n                    attestation.expirationTime,\n                    attestation.data,\n                    HASH_TERMINATOR,\n                    _attestationsCount\n                )\n            );\n    }\n\n    /**\n     * @dev Returns a slice in an array of attestation UUIDs.\n     *\n     * @param uuids The array of attestation UUIDs.\n     * @param start The offset to start from.\n     * @param length The number of total members to retrieve.\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\n     *\n     * @return An array of attestation UUIDs.\n     */\n    function _sliceUUIDs(\n        bytes32[] memory uuids,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) private pure returns (bytes32[] memory) {\n        uint256 attestationsLength = uuids.length;\n        if (attestationsLength == 0) {\n            return new bytes32[](0);\n        }\n\n        if (start >= attestationsLength) {\n            revert InvalidOffset();\n        }\n\n        uint256 len = length;\n        if (attestationsLength < start + length) {\n            len = attestationsLength - start;\n        }\n\n        bytes32[] memory res = new bytes32[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            res[i] = uuids[\n                reverseOrder ? attestationsLength - (start + i + 1) : start + i\n            ];\n        }\n\n        return res;\n    }\n}\n"
    },
    "contracts/Types.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// A representation of an empty/uninitialized UUID.\nbytes32 constant EMPTY_UUID = 0;\n"
    },
    "contracts/interfaces/IEAS.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"./IASRegistry.sol\";\nimport \"./IEASEIP712Verifier.sol\";\n\n/**\n * @title EAS - Ethereum Attestation Service interface\n */\ninterface IEAS {\n    /**\n     * @dev A struct representing a single attestation.\n     */\n    struct Attestation {\n        // A unique identifier of the attestation.\n        bytes32 uuid;\n        // A unique identifier of the AS.\n        bytes32 schema;\n        // The recipient of the attestation.\n        address recipient;\n        // The attester/sender of the attestation.\n        address attester;\n        // The time when the attestation was created (Unix timestamp).\n        uint256 time;\n        // The time when the attestation expires (Unix timestamp).\n        uint256 expirationTime;\n        // The time when the attestation was revoked (Unix timestamp).\n        uint256 revocationTime;\n        // The UUID of the related attestation.\n        bytes32 refUUID;\n        // Custom attestation data.\n        bytes data;\n    }\n\n    /**\n     * @dev Triggered when an attestation has been made.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param attester The attesting account.\n     * @param uuid The UUID the revoked attestation.\n     * @param schema The UUID of the AS.\n     */\n    event Attested(\n        address indexed recipient,\n        address indexed attester,\n        bytes32 uuid,\n        bytes32 indexed schema\n    );\n\n    /**\n     * @dev Triggered when an attestation has been revoked.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param attester The attesting account.\n     * @param schema The UUID of the AS.\n     * @param uuid The UUID the revoked attestation.\n     */\n    event Revoked(\n        address indexed recipient,\n        address indexed attester,\n        bytes32 uuid,\n        bytes32 indexed schema\n    );\n\n    /**\n     * @dev Returns the address of the AS global registry.\n     *\n     * @return The address of the AS global registry.\n     */\n    function getASRegistry() external view returns (IASRegistry);\n\n    /**\n     * @dev Returns the address of the EIP712 verifier used to verify signed attestations.\n     *\n     * @return The address of the EIP712 verifier used to verify signed attestations.\n     */\n    function getEIP712Verifier() external view returns (IEASEIP712Verifier);\n\n    /**\n     * @dev Returns the global counter for the total number of attestations.\n     *\n     * @return The global counter for the total number of attestations.\n     */\n    function getAttestationsCount() external view returns (uint256);\n\n    /**\n     * @dev Attests to a specific AS.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param schema The UUID of the AS.\n     * @param expirationTime The expiration time of the attestation.\n     * @param refUUID An optional related attestation's UUID.\n     * @param data Additional custom data.\n     *\n     * @return The UUID of the new attestation.\n     */\n    function attest(\n        address recipient,\n        bytes32 schema,\n        uint256 expirationTime,\n        bytes32 refUUID,\n        bytes calldata data\n    ) external payable returns (bytes32);\n\n    /**\n     * @dev Attests to a specific AS using a provided EIP712 signature.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param schema The UUID of the AS.\n     * @param expirationTime The expiration time of the attestation.\n     * @param refUUID An optional related attestation's UUID.\n     * @param data Additional custom data.\n     * @param attester The attesting account.\n     * @param v The recovery ID.\n     * @param r The x-coordinate of the nonce R.\n     * @param s The signature data.\n     *\n     * @return The UUID of the new attestation.\n     */\n    function attestByDelegation(\n        address recipient,\n        bytes32 schema,\n        uint256 expirationTime,\n        bytes32 refUUID,\n        bytes calldata data,\n        address attester,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable returns (bytes32);\n\n    /**\n     * @dev Revokes an existing attestation to a specific AS.\n     *\n     * @param uuid The UUID of the attestation to revoke.\n     */\n    function revoke(bytes32 uuid) external;\n\n    /**\n     * @dev Attests to a specific AS using a provided EIP712 signature.\n     *\n     * @param uuid The UUID of the attestation to revoke.\n     * @param attester The attesting account.\n     * @param v The recovery ID.\n     * @param r The x-coordinate of the nonce R.\n     * @param s The signature data.\n     */\n    function revokeByDelegation(\n        bytes32 uuid,\n        address attester,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns an existing attestation by UUID.\n     *\n     * @param uuid The UUID of the attestation to retrieve.\n     *\n     * @return The attestation data members.\n     */\n    function getAttestation(bytes32 uuid)\n        external\n        view\n        returns (Attestation memory);\n\n    /**\n     * @dev Checks whether an attestation exists.\n     *\n     * @param uuid The UUID of the attestation to retrieve.\n     *\n     * @return Whether an attestation exists.\n     */\n    function isAttestationValid(bytes32 uuid) external view returns (bool);\n\n    /**\n     * @dev Checks whether an attestation is active.\n     *\n     * @param uuid The UUID of the attestation to retrieve.\n     *\n     * @return Whether an attestation is active.\n     */\n    function isAttestationActive(bytes32 uuid) external view returns (bool);\n\n    /**\n     * @dev Returns all received attestation UUIDs.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param schema The UUID of the AS.\n     * @param start The offset to start from.\n     * @param length The number of total members to retrieve.\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\n     *\n     * @return An array of attestation UUIDs.\n     */\n    function getReceivedAttestationUUIDs(\n        address recipient,\n        bytes32 schema,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) external view returns (bytes32[] memory);\n\n    /**\n     * @dev Returns the number of received attestation UUIDs.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param schema The UUID of the AS.\n     *\n     * @return The number of attestations.\n     */\n    function getReceivedAttestationUUIDsCount(address recipient, bytes32 schema)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns all sent attestation UUIDs.\n     *\n     * @param attester The attesting account.\n     * @param schema The UUID of the AS.\n     * @param start The offset to start from.\n     * @param length The number of total members to retrieve.\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\n     *\n     * @return An array of attestation UUIDs.\n     */\n    function getSentAttestationUUIDs(\n        address attester,\n        bytes32 schema,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) external view returns (bytes32[] memory);\n\n    /**\n     * @dev Returns the number of sent attestation UUIDs.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param schema The UUID of the AS.\n     *\n     * @return The number of attestations.\n     */\n    function getSentAttestationUUIDsCount(address recipient, bytes32 schema)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns all attestations related to a specific attestation.\n     *\n     * @param uuid The UUID of the attestation to retrieve.\n     * @param start The offset to start from.\n     * @param length The number of total members to retrieve.\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\n     *\n     * @return An array of attestation UUIDs.\n     */\n    function getRelatedAttestationUUIDs(\n        bytes32 uuid,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) external view returns (bytes32[] memory);\n\n    /**\n     * @dev Returns the number of related attestation UUIDs.\n     *\n     * @param uuid The UUID of the attestation to retrieve.\n     *\n     * @return The number of related attestations.\n     */\n    function getRelatedAttestationUUIDsCount(bytes32 uuid)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns all per-schema attestation UUIDs.\n     *\n     * @param schema The UUID of the AS.\n     * @param start The offset to start from.\n     * @param length The number of total members to retrieve.\n     * @param reverseOrder Whether the offset starts from the end and the data is returned in reverse.\n     *\n     * @return An array of attestation UUIDs.\n     */\n    function getSchemaAttestationUUIDs(\n        bytes32 schema,\n        uint256 start,\n        uint256 length,\n        bool reverseOrder\n    ) external view returns (bytes32[] memory);\n\n    /**\n     * @dev Returns the number of per-schema  attestation UUIDs.\n     *\n     * @param schema The UUID of the AS.\n     *\n     * @return The number of attestations.\n     */\n    function getSchemaAttestationUUIDsCount(bytes32 schema)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/IASRegistry.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"./IASResolver.sol\";\n\n/**\n * @title The global AS registry interface.\n */\ninterface IASRegistry {\n    /**\n     * @title A struct representing a record for a submitted AS (Attestation Schema).\n     */\n    struct ASRecord {\n        // A unique identifier of the AS.\n        bytes32 uuid;\n        // Optional schema resolver.\n        IASResolver resolver;\n        // Auto-incrementing index for reference, assigned by the registry itself.\n        uint256 index;\n        // Custom specification of the AS (e.g., an ABI).\n        bytes schema;\n    }\n\n    /**\n     * @dev Triggered when a new AS has been registered\n     *\n     * @param uuid The AS UUID.\n     * @param index The AS index.\n     * @param schema The AS schema.\n     * @param resolver An optional AS schema resolver.\n     * @param attester The address of the account used to register the AS.\n     */\n    event Registered(\n        bytes32 indexed uuid,\n        uint256 indexed index,\n        bytes schema,\n        IASResolver resolver,\n        address attester\n    );\n\n    /**\n     * @dev Submits and reserve a new AS\n     *\n     * @param schema The AS data schema.\n     * @param resolver An optional AS schema resolver.\n     *\n     * @return The UUID of the new AS.\n     */\n    function register(bytes calldata schema, IASResolver resolver)\n        external\n        returns (bytes32);\n\n    /**\n     * @dev Returns an existing AS by UUID\n     *\n     * @param uuid The UUID of the AS to retrieve.\n     *\n     * @return The AS data members.\n     */\n    function getAS(bytes32 uuid) external view returns (ASRecord memory);\n\n    /**\n     * @dev Returns the global counter for the total number of attestations\n     *\n     * @return The global counter for the total number of attestations.\n     */\n    function getASCount() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IEASEIP712Verifier.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n\n// SPDX-License-Identifier: MIT\n\n/**\n * @title EIP712 typed signatures verifier for EAS delegated attestations interface.\n */\ninterface IEASEIP712Verifier {\n    /**\n     * @dev Returns the current nonce per-account.\n     *\n     * @param account The requested accunt.\n     *\n     * @return The current nonce.\n     */\n    function getNonce(address account) external view returns (uint256);\n\n    /**\n     * @dev Verifies signed attestation.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param schema The UUID of the AS.\n     * @param expirationTime The expiration time of the attestation.\n     * @param refUUID An optional related attestation's UUID.\n     * @param data Additional custom data.\n     * @param attester The attesting account.\n     * @param v The recovery ID.\n     * @param r The x-coordinate of the nonce R.\n     * @param s The signature data.\n     */\n    function attest(\n        address recipient,\n        bytes32 schema,\n        uint256 expirationTime,\n        bytes32 refUUID,\n        bytes calldata data,\n        address attester,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Verifies signed revocations.\n     *\n     * @param uuid The UUID of the attestation to revoke.\n     * @param attester The attesting account.\n     * @param v The recovery ID.\n     * @param r The x-coordinate of the nonce R.\n     * @param s The signature data.\n     */\n    function revoke(\n        bytes32 uuid,\n        address attester,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IASResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n\n// SPDX-License-Identifier: MIT\n\n/**\n * @title The interface of an optional AS resolver.\n */\ninterface IASResolver {\n    /**\n     * @dev Returns whether the resolver supports ETH transfers\n     */\n    function isPayable() external pure returns (bool);\n\n    /**\n     * @dev Resolves an attestation and verifier whether its data conforms to the spec.\n     *\n     * @param recipient The recipient of the attestation.\n     * @param schema The AS data schema.\n     * @param data The actual attestation data.\n     * @param expirationTime The expiration time of the attestation.\n     * @param msgSender The sender of the original attestation message.\n     *\n     * @return Whether the data is valid according to the scheme.\n     */\n    function resolve(\n        address recipient,\n        bytes calldata schema,\n        bytes calldata data,\n        uint256 expirationTime,\n        address msgSender\n    ) external payable returns (bool);\n}\n"
    },
    "contracts/tests/resolvers/TestASAttestationResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../../EAS/TellerASResolver.sol\";\nimport \"../../EAS/TellerAS.sol\";\n\n/**\n * @title A sample AS resolver that checks whether an attestations attest to an existing attestation.\n */\ncontract TestASAttestationResolver is TellerASResolver {\n    error Overflow();\n    error OutOfBounds();\n\n    TellerAS private immutable _eas;\n\n    constructor(TellerAS eas) {\n        _eas = eas;\n    }\n\n    function resolve(\n        address, /* recipient */\n        bytes calldata, /* schema */\n        bytes calldata data,\n        uint256, /* expirationTime */\n        address /* msgSender */\n    ) external payable virtual override returns (bool) {\n        return _eas.isAttestationValid(_toBytes32(data, 0));\n    }\n\n    function _toBytes32(bytes memory data, uint256 start)\n        private\n        pure\n        returns (bytes32)\n    {\n        if (start + 32 < start) {\n            revert Overflow();\n        }\n\n        if (data.length < start + 32) {\n            revert OutOfBounds();\n        }\n\n        bytes32 tempBytes32;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            tempBytes32 := mload(add(add(data, 0x20), start))\n        }\n\n        return tempBytes32;\n    }\n}\n"
    },
    "contracts/EAS/TellerASResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../interfaces/IASResolver.sol\";\n\n/**\n * @title A base resolver contract\n */\nabstract contract TellerASResolver is IASResolver {\n    error NotPayable();\n\n    function isPayable() public pure virtual override returns (bool) {\n        return false;\n    }\n\n    receive() external payable virtual {\n        if (!isPayable()) {\n            revert NotPayable();\n        }\n    }\n}\n"
    },
    "contracts/tests/resolvers/TestASValueResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../../EAS/TellerASResolver.sol\";\n\n/**\n * @title A sample AS resolver that checks whether a specific amount of ETH was sent with an attestation.\n */\ncontract TestASValueResolver is TellerASResolver {\n    uint256 private immutable _targetValue;\n\n    constructor(uint256 targetValue) {\n        _targetValue = targetValue;\n    }\n\n    function isPayable() public pure override returns (bool) {\n        return true;\n    }\n\n    function resolve(\n        address, /* recipient */\n        bytes calldata, /* schema */\n        bytes calldata, /* data */\n        uint256, /* expirationTime */\n        address /* msgSender */\n    ) external payable virtual override returns (bool) {\n        return msg.value == _targetValue;\n    }\n}\n"
    },
    "contracts/tests/resolvers/TestASTokenResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../EAS/TellerASResolver.sol\";\n\n/**\n * @title A sample AS resolver that checks whether a specific amount of tokens was approved to be included in an attestation.\n */\ncontract TestASTokenResolver is TellerASResolver {\n    using SafeERC20 for IERC20;\n\n    IERC20 private immutable _targetToken;\n    uint256 private immutable _targetAmount;\n\n    constructor(IERC20 targetToken, uint256 targetAmount) {\n        _targetToken = targetToken;\n        _targetAmount = targetAmount;\n    }\n\n    function resolve(\n        address, /* recipient */\n        bytes calldata, /* schema */\n        bytes calldata, /* data */\n        uint256, /* expirationTime */\n        address msgSender\n    ) external payable virtual override returns (bool) {\n        _targetToken.safeTransferFrom(msgSender, address(this), _targetAmount);\n\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/tests/MarketForwarder_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { Testable } from \"./Testable.sol\";\nimport { TellerV2Context } from \"../TellerV2Context.sol\";\nimport { IMarketRegistry } from \"../interfaces/IMarketRegistry.sol\";\nimport { TellerV2MarketForwarder } from \"../TellerV2MarketForwarder.sol\";\n\ncontract MarketForwarder_Test is Testable, TellerV2MarketForwarder {\n    MarketForwarderTester private tester;\n\n    uint256 private marketId;\n    User private marketOwner;\n    User private user1;\n    User private user2;\n\n    constructor()\n        TellerV2MarketForwarder(address(new MarketForwarderTester()))\n    {\n        tester = MarketForwarderTester(address(getTellerV2()));\n\n        marketOwner = new User(tester);\n        user1 = new User(tester);\n        user2 = new User(tester);\n\n        tester.__setMarketOwner(marketOwner);\n    }\n\n    function setup_beforeAll() public {\n        delete marketId;\n    }\n\n    function setTrustedMarketForwarder_before() public {\n        marketOwner.setTrustedMarketForwarder(marketId, address(this));\n    }\n\n    function setTrustedMarketForwarder_test() public {\n        Test.eq(\n            tester.isTrustedMarketForwarder(marketId, address(this)),\n            true,\n            \"Trusted forwarder was not set\"\n        );\n    }\n\n    function approveMarketForwarder_before() public {\n        setTrustedMarketForwarder_before();\n\n        user1.approveMarketForwarder(marketId, address(this));\n        user2.approveMarketForwarder(marketId, address(this));\n    }\n\n    function approveMarketForwarder_test() public {\n        Test.eq(\n            tester.hasApprovedMarketForwarder(\n                marketId,\n                address(this),\n                address(user1)\n            ),\n            true,\n            \"Borrower did not set market forwarder approval\"\n        );\n        Test.eq(\n            tester.hasApprovedMarketForwarder(\n                marketId,\n                address(this),\n                address(user2)\n            ),\n            true,\n            \"Lender did not set market forwarder approval\"\n        );\n    }\n\n    function forwardUserCall_before() public {\n        approveMarketForwarder_before();\n    }\n\n    function forwardUserCall_test() public {\n        address expectedSender = address(user1);\n        address sender = abi.decode(\n            _forwardCall(\n                abi.encodeWithSelector(\n                    MarketForwarderTester.getSenderForMarket.selector,\n                    marketId\n                ),\n                expectedSender\n            ),\n            (address)\n        );\n        Test.eq(\n            sender,\n            expectedSender,\n            \"Sender address for market does not match expected\"\n        );\n\n        bytes memory expectedData = abi.encodeWithSelector(\n            MarketForwarderTester.getDataForMarket.selector,\n            marketId\n        );\n        bytes memory data = abi.decode(\n            _forwardCall(expectedData, expectedSender),\n            (bytes)\n        );\n        Test.eq0(\n            data,\n            expectedData,\n            \"Function calldata for market does not match expected\"\n        );\n    }\n}\n\ncontract User {\n    TellerV2Context public immutable context;\n\n    constructor(TellerV2Context _context) {\n        context = _context;\n    }\n\n    function setTrustedMarketForwarder(uint256 _marketId, address _forwarder)\n        external\n    {\n        context.setTrustedMarketForwarder(_marketId, _forwarder);\n    }\n\n    function approveMarketForwarder(uint256 _marketId, address _forwarder)\n        external\n    {\n        context.approveMarketForwarder(_marketId, _forwarder);\n    }\n}\n\ncontract MarketForwarderTester is TellerV2Context {\n    constructor() TellerV2Context(address(0)) {}\n\n    function __setMarketOwner(User _marketOwner) external {\n        marketRegistry = IMarketRegistry(\n            address(new MockMarketRegistry(_marketOwner))\n        );\n    }\n\n    function getSenderForMarket(uint256 _marketId)\n        external\n        view\n        returns (address)\n    {\n        return _msgSenderForMarket(_marketId);\n    }\n\n    function getDataForMarket(uint256 _marketId)\n        external\n        view\n        returns (bytes calldata)\n    {\n        return _msgDataForMarket(_marketId);\n    }\n}\n\ncontract MockMarketRegistry {\n    User private immutable marketOwner;\n\n    constructor(User _marketOwner) {\n        marketOwner = _marketOwner;\n    }\n\n    function getMarketOwner(uint256) external view returns (address) {\n        return address(marketOwner);\n    }\n}\n"
    },
    "@mangrovedao/hardhat-test-solidity/test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n// Should be kept in sync with ./lib.js\n\nlibrary Test {\n  /* \n   * Expect events from contracts\n   */\n  event ExpectFrom(address from);\n  event StopExpecting();\n\n  // Usage: from a test contract `t`, call `expectFrom(a)`. \n  // Any subsequent non-special event emitted by `t` will mean \n  // \"I expect `a` to emit the exact same event\". \n  // The order of expectations must be respected.\n  function expectFrom(address from) internal {\n    emit ExpectFrom(from);\n  }\n\n  // After using `expectFrom` and emitting some events you expect\n  // to see emitted elsewhere, you can use `stopExpecting` to emit \n  // further, normal events from your test.\n  function stopExpecting() internal {\n    emit StopExpecting();\n  }\n\n\n  /* \n   * Boolean test\n   */\n  event TestTrue(bool success, string message);\n\n  // Succeed iff success is true\n  function check(bool success, string memory message) internal {\n    emit TestTrue(success, message);\n  }\n\n\n  /* \n   * Always fail, always succeed\n   */\n  function fail(string memory message) internal {\n    emit TestTrue(false, message);\n  }\n\n  function succeed() internal {\n    emit TestTrue(true, \"Success\");\n  }\n\n  /* \n   * Equality testing\n   * ! overloaded as `eq` for everything except for bytes use `eq0`.\n   */\n\n  // Bytes\n  event TestEqBytes(bool success, bytes actual, bytes expected, string message);\n\n  function eq0(\n    bytes memory actual,\n    bytes memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256((actual)) == keccak256((expected));\n    emit TestEqBytes(success, actual, expected, message);\n    return success;\n  }\n\n   // Byte32\n  event TestEqBytes32(\n    bool success,\n    bytes32 actual,\n    bytes32 expected,\n    string message\n  );\n\n  function eq(\n    bytes32 actual,\n    bytes32 expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBytes32(success, actual, expected, message);\n    return success;\n  }\n\n  // Bool\n  event TestEqBool(bool success, bool actual, bool expected, string message);\n  function eq(\n    bool actual,\n    bool expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBool(success, actual, expected, message);\n    return success;\n  }\n\n  // uints\n  event TestEqUint(bool success, uint actual, uint expected, string message);\n\n  function eq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqUint(success, actual, expected, message);\n    return success;\n  }\n\n  // strings\n  event TestEqString(\n    bool success,\n    string actual,\n    string expected,\n    string message\n  );\n\n  function eq(\n    string memory actual,\n    string memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256(bytes((actual))) == keccak256(bytes((expected)));\n    emit TestEqString(success, actual, expected, message);\n    return success;\n  }\n\n  // addresses\n  event TestEqAddress(\n    bool success,\n    address actual,\n    address expected,\n    string message\n  );\n\n\n  function eq(\n    address actual,\n    address expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqAddress(success, actual, expected, message);\n    return success;\n  }\n\n  /* \n   * Inequality testing\n   */\n  event TestLess(bool success, uint actual, uint expected, string message);\n  function less(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual < expected;\n    emit TestLess(success, actual, expected, message);\n    return success;\n  }\n\n  event TestLessEq(bool success, uint actual, uint expected, string message);\n  function lessEq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual <= expected;\n    emit TestLessEq(success, actual, expected, message);\n    return success;\n  }\n\n  event TestMore(bool success, uint actual, uint expected, string message);\n  function more(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual > expected;\n    emit TestMore(success, actual, expected, message);\n    return success;\n  }\n\n  event TestMoreEq(bool success, uint actual, uint expected, string message);\n  function moreEq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual >= expected;\n    emit TestMoreEq(success, actual, expected, message);\n    return success;\n  }\n}\n\n// /* Either cast your arguments to address when you call balanceOf logging functions\n//    or add `is address` to your ERC20s\n//    or use the overloads with `address` types */\ninterface ERC20BalanceOf {\n  function balanceOf(address account) view external returns (uint);\n}\n\n\nlibrary Display {\n  /* ****************************************************************\n   * Register/read address->name mappings to make logs easier to read.\n   *****************************************************************/\n  /* \n   * Names are stored in the contract using the library.\n   */\n\n  // Disgusting hack so a library can manipulate storage refs.\n  bytes32 constant NAMES_POS = keccak256(\"Display.NAMES_POS\");\n  // Store mapping in library caller's storage.\n  // That's quite fragile.\n  struct Registers {\n    mapping(address => string) map;\n  }\n\n  // Also send mapping to javascript test interpreter.  The interpreter COULD\n  // just make an EVM call to map every name but that would probably be very\n  // slow.  So we cache locally.\n  event Register(address addr, string name);\n\n  function registers() internal view returns (Registers storage) {\n    this; // silence warning about pure mutability\n    Registers storage regs;\n    bytes32 _slot = NAMES_POS;\n    assembly {\n      regs.slot := _slot\n    }\n    return regs;\n  }\n\n  /*\n   * Give a name to an address for logging purposes\n   * @example\n   * ```solidity\n   * address addr = address(new Contract());\n   * register(addr,\"My Contract instance\");\n   * ```\n   */\n\n  function register(address addr, string memory name) internal {\n    registers().map[addr] = name;\n    emit Register(addr, name);\n  }\n\n  /*\n   * Read the name of a registered address. Default: \"<not found>\". \n   */\n  function nameOf(address addr) internal view returns (string memory) {\n    string memory s = registers().map[addr];\n    if (keccak256(bytes(s)) != keccak256(bytes(\"\"))) {\n      return s;\n    } else {\n      return \"<not found>\";\n    }\n  }\n\n  /* 1 arg logging (string/uint) */\n\n  event LogString(string a);\n\n  function log(string memory a) internal {\n    emit LogString(a);\n  }\n\n  event LogUint(uint a);\n\n  function log(uint a) internal {\n    emit LogUint(a);\n  }\n\n  /* 2 arg logging (string/uint) */\n\n  event LogStringString(string a, string b);\n\n  function log(string memory a, string memory b) internal {\n    emit LogStringString(a, b);\n  }\n\n  event LogStringUint(string a, uint b);\n\n  function log(string memory a, uint b) internal {\n    emit LogStringUint(a, b);\n  }\n\n  event LogUintUint(uint a, uint b);\n\n  function log(uint a, uint b) internal {\n    emit LogUintUint(a, b);\n  }\n\n  event LogUintString(uint a, string b);\n\n  function log(uint a, string memory b) internal {\n    emit LogUintString(a, b);\n  }\n\n  /* 3 arg logging (string/uint) */\n\n  event LogStringStringString(string a, string b, string c);\n\n  function log(\n    string memory a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogStringStringString(a, b, c);\n  }\n\n  event LogStringStringUint(string a, string b, uint c);\n\n  function log(\n    string memory a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogStringStringUint(a, b, c);\n  }\n\n  event LogStringUintUint(string a, uint b, uint c);\n\n  function log(\n    string memory a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogStringUintUint(a, b, c);\n  }\n\n  event LogStringUintString(string a, uint b, string c);\n\n  function log(\n    string memory a,\n    uint b,\n    string memory c\n  ) internal {\n    emit LogStringUintString(a, b, c);\n  }\n\n  event LogUintUintUint(uint a, uint b, uint c);\n\n  function log(\n    uint a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogUintUintUint(a, b, c);\n  }\n\n  event LogUintStringUint(uint a, string b, uint c);\n\n  function log(\n    uint a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogUintStringUint(a, b, c);\n  }\n\n  event LogUintStringString(uint a, string b, string c);\n\n  function log(\n    uint a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogUintStringString(a, b, c);\n  }\n\n  /* End of register/read section */\n  event ERC20Balances(address[] tokens, address[] accounts, uint[] balances);\n\n  function logBalances(\n    address[1] memory _tokens, \n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  /* takes [t1,...,tM], [a1,...,aN]\n       logs also [...b(t1,aj) ... b(tM,aj) ...] */\n\n  function logBalances(address[] memory tokens, address[] memory accounts)\n    internal\n  {\n    uint[] memory balances = new uint[](tokens.length * accounts.length);\n    for (uint i = 0; i < tokens.length; i++) {\n      for (uint j = 0; j < accounts.length; j++) {\n        uint bal = ERC20BalanceOf(tokens[i]).balanceOf(accounts[j]);\n        balances[i * accounts.length + j] = bal;\n        //console.log(tokens[i].symbol(),nameOf(accounts[j]),bal);\n      }\n    }\n    emit ERC20Balances(tokens, accounts, balances);\n  }\n\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/tests/Testable.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n\n// SPDX-License-Identifier: MIT\n\nabstract contract Testable {\n    receive() external payable {}\n}\n"
    },
    "contracts/TellerV2Context.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"./TellerV2Storage.sol\";\nimport \"./ERC2771ContextUpgradeable.sol\";\n\nabstract contract TellerV2Context is\n    ERC2771ContextUpgradeable,\n    TellerV2Storage\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    event TrustedMarketForwarderSet(\n        uint256 indexed marketId,\n        address forwarder,\n        address sender\n    );\n    event MarketForwarderApproved(\n        uint256 indexed marketId,\n        address indexed forwarder,\n        address sender\n    );\n\n    constructor(address trustedForwarder)\n        ERC2771ContextUpgradeable(trustedForwarder)\n    {}\n\n    /**\n     * @notice Checks if an address is a trusted forwarder contract for a given market.\n     * @param _marketId An ID for a lending market.\n     * @param _trustedMarketForwarder An address to check if is a trusted forwarder in the given market.\n     * @return A boolean indicating the forwarder address is trusted in a market.\n     */\n    function isTrustedMarketForwarder(\n        uint256 _marketId,\n        address _trustedMarketForwarder\n    ) public view returns (bool) {\n        return _trustedMarketForwarders[_marketId] == _trustedMarketForwarder;\n    }\n\n    /**\n     * @notice Checks if an account has approved a forwarder for a market.\n     * @param _marketId An ID for a lending market.\n     * @param _forwarder A forwarder contract address.\n     * @param _account The address to verify set an approval.\n     * @return A boolean indicating if an approval was set.\n     */\n    function hasApprovedMarketForwarder(\n        uint256 _marketId,\n        address _forwarder,\n        address _account\n    ) public view returns (bool) {\n        return\n            isTrustedMarketForwarder(_marketId, _forwarder) &&\n            _approvedForwarderSenders[_forwarder].contains(_account);\n    }\n\n    /**\n     * @notice Sets a trusted forwarder for a lending market.\n     * @notice The caller must owner the market given. See {MarketRegistry}\n     * @param _marketId An ID for a lending market.\n     * @param _forwarder A forwarder contract address.\n     */\n    function setTrustedMarketForwarder(uint256 _marketId, address _forwarder)\n        external\n    {\n        require(\n            marketRegistry.getMarketOwner(_marketId) == _msgSender(),\n            \"Caller must be the market owner\"\n        );\n        _trustedMarketForwarders[_marketId] = _forwarder;\n        emit TrustedMarketForwarderSet(_marketId, _forwarder, _msgSender());\n    }\n\n    /**\n     * @notice Approves a forwarder contract to use their address as a sender for a specific market.\n     * @notice The forwarder given must be trusted by the market given.\n     * @param _marketId An ID for a lending market.\n     * @param _forwarder A forwarder contract address.\n     */\n    function approveMarketForwarder(uint256 _marketId, address _forwarder)\n        external\n    {\n        require(\n            isTrustedMarketForwarder(_marketId, _forwarder),\n            \"Forwarder must be trusted by the market\"\n        );\n        _approvedForwarderSenders[_forwarder].add(_msgSender());\n        emit MarketForwarderApproved(_marketId, _forwarder, _msgSender());\n    }\n\n    /**\n     * @notice Retrieves the function caller address by checking the appended calldata if the _actual_ caller is a trusted forwarder.\n     * @param _marketId An ID for a lending market.\n     * @return sender The address to use as the function caller.\n     */\n    function _msgSenderForMarket(uint256 _marketId)\n        internal\n        view\n        virtual\n        returns (address)\n    {\n        if (isTrustedMarketForwarder(_marketId, _msgSender())) {\n            address sender;\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n            // Ensure the appended sender address approved the forwarder\n            require(\n                _approvedForwarderSenders[_msgSender()].contains(sender),\n                \"Sender must approve market forwarder\"\n            );\n            return sender;\n        }\n\n        return _msgSender();\n    }\n\n    /**\n     * @notice Retrieves the actual function calldata from a trusted forwarder call.\n     * @param _marketId An ID for a lending market to verify if the caller is a trusted forwarder.\n     * @return calldata The modified bytes array of the function calldata without the appended sender's address.\n     */\n    function _msgDataForMarket(uint256 _marketId)\n        internal\n        view\n        virtual\n        returns (bytes calldata)\n    {\n        if (isTrustedMarketForwarder(_marketId, _msgSender())) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return _msgData();\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IMarketRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMarketRegistry {\n    function isVerifiedLender(uint256 _marketId, address _lender)\n        external\n        returns (bool, bytes32);\n\n    function isMarketClosed(uint256 _marketId) external returns (bool);\n\n    function isVerifiedBorrower(uint256 _marketId, address _borrower)\n        external\n        returns (bool, bytes32);\n\n    function getMarketOwner(uint256 _marketId) external returns (address);\n\n    function getMarketURI(uint256 _marketId) external returns (string memory);\n\n    function getPaymentCycleDuration(uint256 _marketId)\n        external\n        returns (uint32);\n\n    function getPaymentDefaultDuration(uint256 _marketId)\n        external\n        returns (uint32);\n\n    function getBidExpirationTime(uint256 _marketId) external returns (uint32);\n\n    function getMarketplaceFee(uint256 _marketId) external returns (uint16);\n}\n"
    },
    "contracts/TellerV2MarketForwarder.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"./TellerV2.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @dev Simple helper contract to forward an encoded function call to the TellerV2 contract. See {TellerV2Context}\n */\nabstract contract TellerV2MarketForwarder {\n    using AddressUpgradeable for address;\n\n    address private immutable _tellerV2;\n\n    constructor(address _protocolAddress) {\n        _tellerV2 = _protocolAddress;\n    }\n\n    function getTellerV2() public view returns (TellerV2) {\n        return TellerV2(_tellerV2);\n    }\n\n    /**\n     * @dev Performs function call to the TellerV2 contract by appending an address to the calldata.\n     * @param _data The encoded function calldata on TellerV2.\n     * @param _msgSender The address that should be treated as the underlying function caller.\n     * @return The encoded response from the called function.\n     *\n     * Requirements:\n     *  - The {_msgSender} address must set an approval on TellerV2 for this forwarder contract __before__ making this call.\n     */\n    function _forwardCall(bytes memory _data, address _msgSender)\n        internal\n        returns (bytes memory)\n    {\n        return\n            address(_tellerV2).functionCall(\n                abi.encodePacked(_data, _msgSender)\n            );\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/TellerV2Storage.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nabstract contract TellerV2Storage_G0 {\n    enum BidState {\n        NONEXISTENT,\n        PENDING,\n        CANCELLED,\n        ACCEPTED,\n        PAID,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice Represents a total amount for a payment.\n     * @param principal Amount that counts towards the principal.\n     * @param interest  Amount that counts toward interest.\n     */\n    struct Payment {\n        uint256 principal;\n        uint256 interest;\n    }\n\n    /**\n     * @notice Details about the loan.\n     * @param lendingToken The token address for the loan.\n     * @param principal The amount of tokens initially lent out.\n     * @param totalRepaid Payment struct that represents the total principal and interest amount repaid.\n     * @param timestamp Timestamp, in seconds, of when the bid was submitted by the borrower.\n     * @param acceptedTimestamp Timestamp, in seconds, of when the bid was accepted by the lender.\n     * @param lastRepaidTimestamp Timestamp, in seconds, of when the last payment was made\n     * @param loanDuration The duration of the loan.\n     */\n    struct LoanDetails {\n        ERC20 lendingToken;\n        uint256 principal;\n        Payment totalRepaid;\n        uint32 timestamp;\n        uint32 acceptedTimestamp;\n        uint32 lastRepaidTimestamp;\n        uint32 loanDuration;\n    }\n\n    /**\n     * @notice Details about a loan request.\n     * @param borrower Account address who is requesting a loan.\n     * @param receiver Account address who will receive the loan amount.\n     * @param lender Account address who accepted and funded the loan request.\n     * @param marketplaceId ID of the marketplace the bid was submitted to.\n     * @param metadataURI ID of off chain metadata to find additional information of the loan request.\n     * @param loanDetails Struct of the specific loan details.\n     * @param terms Struct of the loan request terms.\n     * @param state Represents the current state of the loan.\n     */\n    struct Bid {\n        address borrower;\n        address receiver;\n        address lender;\n        uint256 marketplaceId;\n        bytes32 _metadataURI; // DEPRECIATED\n        LoanDetails loanDetails;\n        Terms terms;\n        BidState state;\n    }\n\n    /**\n     * @notice Information on the terms of a loan request\n     * @param paymentCycleAmount Value of tokens expected to be repaid every payment cycle.\n     * @param paymentCycle Duration, in seconds, of how often a payment must be made.\n     * @param APR Annual percentage rating to be applied on repayments. (10000 == 100%)\n     */\n    struct Terms {\n        uint256 paymentCycleAmount;\n        uint32 paymentCycle;\n        uint16 APR;\n    }\n\n    /** Storage Variables */\n\n    // Current number of bids.\n    uint256 public bidId = 0;\n\n    // Mapping of bidId to bid information.\n    mapping(uint256 => Bid) public bids;\n\n    // Mapping of borrowers to borrower requests.\n    mapping(address => uint256[]) public borrowerBids;\n\n    // Mapping of volume filled by lenders.\n    mapping(address => uint256) public _lenderVolumeFilled; // DEPRECIATED\n\n    // Volume filled by all lenders.\n    uint256 public _totalVolumeFilled; // DEPRECIATED\n\n    // List of allowed lending tokens\n    EnumerableSet.AddressSet internal lendingTokensSet;\n\n    IMarketRegistry public marketRegistry;\n    IReputationManager public reputationManager;\n\n    // Mapping of borrowers to borrower requests.\n    mapping(address => EnumerableSet.UintSet) internal _borrowerBidsActive;\n\n    mapping(uint256 => uint32) public bidDefaultDuration;\n    mapping(uint256 => uint32) public bidExpirationTime;\n\n    // Mapping of volume filled by lenders.\n    // Asset address => Lender address => Volume amount\n    mapping(address => mapping(address => uint256)) public lenderVolumeFilled;\n\n    // Volume filled by all lenders.\n    // Asset address => Volume amount\n    mapping(address => uint256) public totalVolumeFilled;\n\n    uint256 public version;\n\n    // Mapping of metadataURIs by bidIds.\n    // Bid Id => metadataURI string\n    mapping(uint256 => string) public uris;\n}\n\nabstract contract TellerV2Storage_G1 is TellerV2Storage_G0 {\n    // market ID => trusted forwarder\n    mapping(uint256 => address) internal _trustedMarketForwarders;\n    // trusted forwarder => set of pre-approved senders\n    mapping(address => EnumerableSet.AddressSet)\n        internal _approvedForwarderSenders;\n}\n\nabstract contract TellerV2Storage is TellerV2Storage_G1 {}\n"
    },
    "contracts/ERC2771ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n * @dev This is modified from the OZ library to remove the gap of storage variables at the end.\n */\nabstract contract ERC2771ContextUpgradeable is\n    Initializable,\n    ContextUpgradeable\n{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder) {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override\n        returns (address sender)\n    {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override\n        returns (bytes calldata)\n    {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IReputationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum RepMark {\n    Good,\n    Delinquent,\n    Default\n}\n\ninterface IReputationManager {\n    function getDelinquentLoanIds(address _account)\n        external\n        returns (uint256[] memory);\n\n    function getDefaultedLoanIds(address _account)\n        external\n        returns (uint256[] memory);\n\n    function getCurrentDelinquentLoanIds(address _account)\n        external\n        returns (uint256[] memory);\n\n    function getCurrentDefaultLoanIds(address _account)\n        external\n        returns (uint256[] memory);\n\n    function updateAccountReputation(address _account) external;\n\n    function updateAccountReputation(address _account, uint256 _bidId)\n        external\n        returns (RepMark);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/TellerV2.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/NumbersLib.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for ERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _lendingTokens The list of tokens allowed as lending assets on the protocol.\n     */\n    function initialize(\n        uint16 _protocolFee,\n        address _marketRegistry,\n        address _reputationManager,\n        address[] memory _lendingTokens\n    ) external initializer {\n        __ProtocolFee_init(_protocolFee);\n\n        __Pausable_init();\n\n        marketRegistry = IMarketRegistry(_marketRegistry);\n        reputationManager = IReputationManager(_reputationManager);\n\n        require(_lendingTokens.length > 0, \"No lending tokens specified\");\n        for (uint256 i = 0; i < _lendingTokens.length; i++) {\n            require(\n                _lendingTokens[i].isContract(),\n                \"lending token not contract\"\n            );\n            addLendingToken(_lendingTokens[i]);\n        }\n    }\n\n    function onUpgrade() external {\n        require(version == 1, \"Contract already upgraded!\");\n        version++;\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        if (chainId != 137) {\n            return;\n        }\n        for (uint256 i = 62; i < 66; i++) {\n            bids[i].terms.paymentCycleAmount = NumbersLib.pmt(\n                bids[i].loanDetails.principal,\n                bids[i].loanDetails.loanDuration,\n                bids[i].terms.paymentCycle,\n                bids[i].terms.APR\n            );\n        }\n    }\n\n    /**\n     * @notice Gets the metadataURI for a bidId.\n     * @param _bidId The id of the bid to return the metadataURI for\n     * @return metadataURI_ The metadataURI for the bid, as a string.\n     */\n    function getMetadataURI(uint256 _bidId)\n        public\n        view\n        returns (string memory metadataURI_)\n    {\n        // Check uri mapping first\n        metadataURI_ = uris[_bidId];\n        // If the URI is not present in the mapping\n        if (\n            keccak256(abi.encodePacked(metadataURI_)) ==\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 // hardcoded constant of keccak256('')\n        ) {\n            // Return depreciated bytes32 uri as a string\n            uint256 convertedURI = uint256(bids[_bidId]._metadataURI);\n            metadataURI_ = StringsUpgradeable.toHexString(convertedURI, 32);\n        }\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol to set a new reputation manager contract.\n     * @param _reputationManager The new contract address.\n     */\n    function setReputationManager(address _reputationManager) public onlyOwner {\n        reputationManager = IReputationManager(_reputationManager);\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        address sender = _msgSenderForMarket(_marketplaceId);\n        (bool isVerified, ) = marketRegistry.isVerifiedBorrower(\n            _marketplaceId,\n            sender\n        );\n        require(isVerified, \"Not verified borrower\");\n        require(\n            !marketRegistry.isMarketClosed(_marketplaceId),\n            \"Market is closed\"\n        );\n        require(\n            lendingTokensSet.contains(_lendingToken),\n            \"Lending token not authorized\"\n        );\n\n        // Set response bid ID.\n        bidId_ = bidId;\n\n        // Create and store our bid into the mapping\n        Bid storage bid = bids[bidId];\n        bid.borrower = sender;\n        bid.receiver = _receiver != address(0) ? _receiver : bid.borrower;\n        bid.marketplaceId = _marketplaceId;\n        bid.loanDetails.lendingToken = ERC20(_lendingToken);\n        bid.loanDetails.principal = _principal;\n        bid.loanDetails.loanDuration = _duration;\n        bid.loanDetails.timestamp = uint32(block.timestamp);\n\n        bid.terms.paymentCycle = marketRegistry.getPaymentCycleDuration(\n            _marketplaceId\n        );\n        bid.terms.APR = _APR;\n\n        bidDefaultDuration[bidId] = marketRegistry.getPaymentDefaultDuration(\n            _marketplaceId\n        );\n\n        bidExpirationTime[bidId] = marketRegistry.getBidExpirationTime(\n            _marketplaceId\n        );\n\n        bid.terms.paymentCycleAmount = NumbersLib.pmt(\n            _principal,\n            _duration,\n            bid.terms.paymentCycle,\n            _APR\n        );\n\n        uris[bidId] = _metadataURI;\n        bid.state = BidState.PENDING;\n\n        emit SubmittedBid(\n            bidId,\n            bid.borrower,\n            bid.receiver,\n            keccak256(abi.encodePacked(_metadataURI))\n        );\n\n        // Store bid inside borrower bids mapping\n        borrowerBids[bid.borrower].push(bidId);\n\n        // Increment bid id counter\n        bidId++;\n    }\n\n    /**\n     * @notice Function for users to cancel a bid.\n     * @param _bidId The id of the bid to be cancelled.\n     */\n    function cancelBid(uint256 _bidId)\n        external\n        pendingBid(_bidId, \"cancelBid\")\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        if (bid.borrower != _msgSenderForMarket(bid.marketplaceId)) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"cancelBid\",\n                message: \"Only the bid owner can cancel!\"\n            });\n        }\n\n        // Set the bid state to CANCELLED\n        bid.state = BidState.CANCELLED;\n\n        // Emit CancelledBid event\n        emit CancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a lender to accept a proposed loan bid.\n     * @param _bidId The id of the loan bid to accept.\n     */\n    function lenderAcceptBid(uint256 _bidId)\n        external\n        override\n        pendingBid(_bidId, \"lenderAcceptBid\")\n        whenNotPaused\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n        (bool isVerified, ) = marketRegistry.isVerifiedLender(\n            bid.marketplaceId,\n            sender\n        );\n        require(isVerified, \"Not verified lender\");\n\n        require(\n            !marketRegistry.isMarketClosed(bid.marketplaceId),\n            \"Market is closed\"\n        );\n\n        require(!isLoanExpired(_bidId), \"Bid has expired\");\n\n        // Set timestamp\n        bid.loanDetails.acceptedTimestamp = uint32(block.timestamp);\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // Mark borrower's request as accepted\n        bid.state = BidState.ACCEPTED;\n\n        // Declare the bid acceptor as the lender of the bid\n        bid.lender = sender;\n\n        // Transfer funds to borrower from the lender\n        uint256 amountToProtocol = bid.loanDetails.principal.percent(\n            protocolFee()\n        );\n        uint256 amountToMarketplace = bid.loanDetails.principal.percent(\n            marketRegistry.getMarketplaceFee(bid.marketplaceId)\n        );\n        uint256 amountToBorrower = bid.loanDetails.principal -\n            amountToProtocol -\n            amountToMarketplace;\n        //transfer fee to protocol\n        bid.loanDetails.lendingToken.safeTransferFrom(\n            bid.lender,\n            owner(),\n            amountToProtocol\n        );\n\n        //transfer fee to marketplace\n        bid.loanDetails.lendingToken.safeTransferFrom(\n            bid.lender,\n            marketRegistry.getMarketOwner(bid.marketplaceId),\n            amountToMarketplace\n        );\n\n        //transfer funds to borrower\n        bid.loanDetails.lendingToken.safeTransferFrom(\n            bid.lender,\n            bid.receiver,\n            amountToBorrower\n        );\n\n        // Record volume filled by lenders\n        lenderVolumeFilled[address(bid.loanDetails.lendingToken)][\n            bid.lender\n        ] += bid.loanDetails.principal;\n        totalVolumeFilled[address(bid.loanDetails.lendingToken)] += bid\n            .loanDetails\n            .principal;\n\n        // Add borrower's active bid\n        _borrowerBidsActive[bid.borrower].add(_bidId);\n\n        // Emit AcceptedBid\n        emit AcceptedBid(_bidId, bid.lender);\n\n        emit FeePaid(_bidId, \"protocol\", amountToProtocol);\n        emit FeePaid(_bidId, \"marketplace\", amountToMarketplace);\n    }\n\n    /**\n     * @notice Function for users to make the minimum amount due for an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanMinimum(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(bids[_bidId], block.timestamp);\n        _repayLoan(\n            _bidId,\n            Payment({ principal: duePrincipal, interest: interest }),\n            owedPrincipal + interest\n        );\n    }\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(bids[_bidId], block.timestamp);\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest\n        );\n    }\n\n    // function that the borrower (ideally) sends to repay the loan\n    /**\n     * @notice Function for users to make a payment towards an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _amount The amount of the payment.\n     */\n    function repayLoan(uint256 _bidId, uint256 _amount)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(bids[_bidId], block.timestamp);\n        uint256 minimumOwed = duePrincipal + interest;\n\n        // If amount is less than minimumOwed, we revert\n        if (_amount < minimumOwed) {\n            revert PaymentNotMinimum(_bidId, _amount, minimumOwed);\n        }\n\n        _repayLoan(\n            _bidId,\n            Payment({ principal: _amount - interest, interest: interest }),\n            owedPrincipal + interest\n        );\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol implement an emergency stop mechanism.\n     */\n    function pauseProtocol() public virtual onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol undo a previously implemented emergency stop.\n     */\n    function unpauseProtocol() public virtual onlyOwner whenPaused {\n        _unpause();\n    }\n\n    //TODO: add an incentive for liquidator\n    /**\n     * @notice Function for users to liquidate a defaulted loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function liquidateLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        require(isLoanDefaulted(_bidId), \"Loan must be defaulted.\");\n\n        Bid storage bid = bids[_bidId];\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(bid, block.timestamp);\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest\n        );\n\n        bid.state = BidState.LIQUIDATED;\n\n        emit LoanLiquidated(_bidId, _msgSenderForMarket(bid.marketplaceId));\n    }\n\n    /**\n     * @notice Internal function to make a loan payment.\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _payment The Payment struct with payments amounts towards principal and interest respectively.\n     * @param _owedAmount The total amount owed on the loan.\n     */\n    function _repayLoan(\n        uint256 _bidId,\n        Payment memory _payment,\n        uint256 _owedAmount\n    ) internal {\n        Bid storage bid = bids[_bidId];\n        uint256 paymentAmount = _payment.principal + _payment.interest;\n\n        RepMark mark = reputationManager.updateAccountReputation(\n            bid.borrower,\n            _bidId\n        );\n\n        // Check if we are sending a payment or amount remaining\n        if (paymentAmount >= _owedAmount) {\n            paymentAmount = _owedAmount;\n            bid.state = BidState.PAID;\n\n            // Remove borrower's active bid\n            _borrowerBidsActive[bid.borrower].remove(_bidId);\n\n            emit LoanRepaid(_bidId);\n        } else {\n            emit LoanRepayment(_bidId);\n        }\n        // Send payment to the lender\n        bid.loanDetails.lendingToken.safeTransferFrom(\n            _msgSenderForMarket(bid.marketplaceId),\n            bid.lender,\n            paymentAmount\n        );\n\n        // update our mappings\n        bid.loanDetails.totalRepaid.principal += _payment.principal;\n        bid.loanDetails.totalRepaid.interest += _payment.interest;\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // If the loan is paid in full and has a mark, we should update the current reputation\n        if (mark != RepMark.Good) {\n            reputationManager.updateAccountReputation(bid.borrower, _bidId);\n        }\n    }\n\n    /**\n     * @notice Calculates the total amount owed for a bid.\n     * @param _bidId The id of the loan bid to calculate the owed amount for.\n     */\n    function calculateAmountOwed(uint256 _bidId)\n        public\n        view\n        returns (Payment memory owed)\n    {\n        if (bids[_bidId].state != BidState.ACCEPTED) return owed;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(bids[_bidId], block.timestamp);\n        owed.principal = owedPrincipal;\n        owed.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the total amount owed for a loan bid at a specific timestamp.\n     * @param _bidId The id of the loan bid to calculate the owed amount for.\n     * @param _timestamp The timestamp at which to calculate the loan owed amount at.\n     */\n    function calculateAmountOwed(uint256 _bidId, uint256 _timestamp)\n        public\n        view\n        returns (Payment memory owed)\n    {\n        Bid storage bid = bids[_bidId];\n        if (\n            bid.state != BidState.ACCEPTED ||\n            bid.loanDetails.acceptedTimestamp >= _timestamp\n        ) return owed;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(bid, _timestamp);\n        owed.principal = owedPrincipal;\n        owed.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the minimum payment amount due for a loan.\n     * @param _bidId The id of the loan bid to get the payment amount for.\n     */\n    function calculateAmountDue(uint256 _bidId)\n        public\n        view\n        returns (Payment memory due)\n    {\n        if (bids[_bidId].state != BidState.ACCEPTED) return due;\n\n        (, uint256 duePrincipal, uint256 interest) = V2Calculations\n            .calculateAmountOwed(bids[_bidId], block.timestamp);\n        due.principal = duePrincipal;\n        due.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the minimum payment amount due for a loan at a specific timestamp.\n     * @param _bidId The id of the loan bid to get the payment amount for.\n     * @param _timestamp The timestamp at which to get the due payment at.\n     */\n    function calculateAmountDue(uint256 _bidId, uint256 _timestamp)\n        public\n        view\n        returns (Payment memory due)\n    {\n        Bid storage bid = bids[_bidId];\n        if (\n            bids[_bidId].state != BidState.ACCEPTED ||\n            bid.loanDetails.acceptedTimestamp >= _timestamp\n        ) return due;\n\n        (, uint256 duePrincipal, uint256 interest) = V2Calculations\n            .calculateAmountOwed(bid, _timestamp);\n        due.principal = duePrincipal;\n        due.interest = interest;\n    }\n\n    /**\n     * @notice Returns the next due date for a loan payment.\n     * @param _bidId The id of the loan bid.\n     */\n    function calculateNextDueDate(uint256 _bidId)\n        public\n        view\n        returns (uint32 dueDate_)\n    {\n        Bid storage bid = bids[_bidId];\n        if (bids[_bidId].state != BidState.ACCEPTED) return dueDate_;\n\n        // Start with the original due date being 1 payment cycle since bid was accepted\n        dueDate_ = bid.loanDetails.acceptedTimestamp + bid.terms.paymentCycle;\n\n        // Calculate the cycle number the last repayment was made\n        uint32 delta = lastRepaidTimestamp(_bidId) -\n            bid.loanDetails.acceptedTimestamp;\n        if (delta > 0) {\n            uint32 repaymentCycle = 1 + (delta / bid.terms.paymentCycle);\n            dueDate_ += (repaymentCycle * bid.terms.paymentCycle);\n        }\n\n        //if we are in the last payment cycle, the next due date is the end of loan duration\n        if (\n            dueDate_ >\n            bid.loanDetails.acceptedTimestamp + bid.loanDetails.loanDuration\n        ) {\n            dueDate_ =\n                bid.loanDetails.acceptedTimestamp +\n                bid.loanDetails.loanDuration;\n        }\n    }\n\n    /**\n     * @notice Checks to see if a borrower is delinquent.\n     * @param _bidId The id of the loan bid to check for.\n     */\n    function isPaymentLate(uint256 _bidId) public view override returns (bool) {\n        if (bids[_bidId].state != BidState.ACCEPTED) return false;\n        return uint32(block.timestamp) > calculateNextDueDate(_bidId);\n    }\n\n    /**\n     * @notice Checks to see if a borrower is delinquent.\n     * @param _bidId The id of the loan bid to check for.\n     */\n    function isLoanDefaulted(uint256 _bidId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        Bid storage bid = bids[_bidId];\n\n        // Make sure loan cannot be liquidated if it is not active\n        if (bid.state != BidState.ACCEPTED) return false;\n\n        if (bidDefaultDuration[_bidId] == 0) return false;\n\n        return (uint32(block.timestamp) - lastRepaidTimestamp(_bidId) >\n            bidDefaultDuration[_bidId]);\n    }\n\n    function getBidState(uint256 _bidId)\n        external\n        view\n        override\n        returns (BidState)\n    {\n        return bids[_bidId].state;\n    }\n\n    function getBorrowerActiveLoanIds(address _borrower)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _borrowerBidsActive[_borrower].values();\n    }\n\n    function getBorrowerLoanIds(address _borrower)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return borrowerBids[_borrower];\n    }\n\n    /**\n     * @notice Checks to see if a pending loan has expired so it is no longer able to be accepted.\n     * @param _bidId The id of the loan bid to check for.\n     */\n    function isLoanExpired(uint256 _bidId) public view returns (bool) {\n        Bid storage bid = bids[_bidId];\n\n        if (bid.state != BidState.PENDING) return false;\n        if (bidExpirationTime[_bidId] == 0) return false;\n\n        return (uint32(block.timestamp) >\n            bid.loanDetails.timestamp + bidExpirationTime[_bidId]);\n    }\n\n    /**\n     * @notice Returns the last repaid timestamp for a loan.\n     * @param _bidId The id of the loan bid to get the timestamp for.\n     */\n    function lastRepaidTimestamp(uint256 _bidId) public view returns (uint32) {\n        return V2Calculations.lastRepaidTimestamp(bids[_bidId]);\n    }\n\n    /**\n     * @notice Returns the list of authorized tokens on the protocol.\n     */\n    function getLendingTokens() public view returns (address[] memory) {\n        return lendingTokensSet.values();\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol add an authorized lending token.\n     * @param _lendingToken The contract address of the lending token.\n     */\n    function addLendingToken(address _lendingToken) public onlyOwner {\n        require(_lendingToken.isContract(), \"Incorrect lending token address\");\n        lendingTokensSet.add(_lendingToken);\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol remove an authorized lending token.\n     * @param _lendingToken The contract address of the lending token.\n     */\n    function removeLendingToken(address _lendingToken) public onlyOwner {\n        lendingTokensSet.remove(_lendingToken);\n    }\n\n    /**\n     * @notice Returns the borrower address for a given bid.\n     * @param _bidId The id of the bid/loan to get the borrower for.\n     * @return borrower_ The address of the borrower associated with the bid.\n     */\n    function getLoanBorrower(uint256 _bidId)\n        external\n        view\n        returns (address borrower_)\n    {\n        borrower_ = bids[_bidId].borrower;\n    }\n\n    /**\n     * @notice Returns the lender address for a given bid.\n     * @param _bidId The id of the bid/loan to get the lender for.\n     * @return lender_ The address of the lender associated with the bid.\n     */\n    function getLoanLender(uint256 _bidId)\n        external\n        view\n        returns (address lender_)\n    {\n        lender_ = bids[_bidId].lender;\n    }\n\n    /** OpenZeppelin Override Functions **/\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ERC2771ContextUpgradeable, ContextUpgradeable)\n        returns (address sender)\n    {\n        sender = ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ERC2771ContextUpgradeable, ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n}\n\nlibrary V2Calculations {\n    using NumbersLib for uint256;\n\n    /**\n     * @notice Returns the timestamp of the last payment made for a loan.\n     * @param _bid The loan bid struct to get the timestamp for.\n     */\n    function lastRepaidTimestamp(TellerV2.Bid storage _bid)\n        internal\n        view\n        returns (uint32)\n    {\n        return\n            _bid.loanDetails.lastRepaidTimestamp == 0\n                ? _bid.loanDetails.acceptedTimestamp\n                : _bid.loanDetails.lastRepaidTimestamp;\n    }\n\n    /**\n     * @notice Calculates the amount owed for a loan.\n     * @param _bid The loan bid struct to get the owed amount for.\n     * @param _timestamp The timestamp at which to get the owed amount at.\n     */\n    function calculateAmountOwed(TellerV2.Bid storage _bid, uint256 _timestamp)\n        internal\n        view\n        returns (\n            uint256 owedPrincipal_,\n            uint256 duePrincipal_,\n            uint256 interest_\n        )\n    {\n        // Total principal left to pay\n        owedPrincipal_ =\n            _bid.loanDetails.principal -\n            _bid.loanDetails.totalRepaid.principal;\n        uint256 interestOwedInAYear = owedPrincipal_.percent(_bid.terms.APR);\n        uint256 owedTime = _timestamp - uint256(lastRepaidTimestamp(_bid));\n        interest_ = (interestOwedInAYear * owedTime) / 365 days;\n\n        // Max payable amount in a cycle\n        // NOTE: the last cycle could have less than the calculated payment amount\n        uint256 maxCycleOwed = Math.min(\n            _bid.terms.paymentCycleAmount,\n            owedPrincipal_ + interest_\n        );\n\n        // Calculate accrued amount due since last repayment\n        uint256 owedAmount = (maxCycleOwed * owedTime) /\n            _bid.terms.paymentCycle;\n        duePrincipal_ = owedAmount - interest_;\n    }\n}\n"
    },
    "contracts/ProtocolFee.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract ProtocolFee is OwnableUpgradeable {\n    // Protocol fee set for loan processing.\n    uint16 private _protocolFee;\n\n    /**\n     * @notice This event is emitted when the protocol fee has been updated.\n     * @param newFee The new protocol fee set.\n     * @param oldFee The previously set protocol fee.\n     */\n    event ProtocolFeeSet(uint16 newFee, uint16 oldFee);\n\n    /**\n     * @notice Initialized the protocol fee.\n     * @param initFee The initial protocol fee to be set on the protocol.\n     */\n    function __ProtocolFee_init(uint16 initFee) internal onlyInitializing {\n        __Ownable_init();\n        __ProtocolFee_init_unchained(initFee);\n    }\n\n    function __ProtocolFee_init_unchained(uint16 initFee)\n        internal\n        onlyInitializing\n    {\n        setProtocolFee(initFee);\n    }\n\n    /**\n     * @notice Returns the current protocol fee.\n     */\n    function protocolFee() public view virtual returns (uint16) {\n        return _protocolFee;\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol to set a new protocol fee.\n     * @param newFee The new protocol fee to be set.\n     */\n    function setProtocolFee(uint16 newFee) public virtual onlyOwner {\n        // Skip if the fee is the same\n        if (newFee == _protocolFee) return;\n\n        uint16 oldFee = _protocolFee;\n        _protocolFee = newFee;\n        emit ProtocolFeeSet(newFee, oldFee);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/interfaces/ITellerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../TellerV2Storage.sol\";\n\ninterface ITellerV2 {\n    /**\n     * @notice Function for a borrower to create a bid for a loan.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) external returns (uint256 bidId_);\n\n    /**\n     * @notice Function for a lender to accept a proposed loan bid.\n     * @param _bidId The id of the loan bid to accept.\n     */\n    function lenderAcceptBid(uint256 _bidId) external;\n\n    /**\n     * @notice Function for users to make the minimum amount due for an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanMinimum(uint256 _bidId) external;\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFull(uint256 _bidId) external;\n\n    /**\n     * @notice Function for users to make a payment towards an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _amount The amount of the payment.\n     */\n    function repayLoan(uint256 _bidId, uint256 _amount) external;\n\n    /**\n     * @notice Checks to see if a borrower is delinquent.\n     * @param _bidId The id of the loan bid to check for.\n     */\n    function isLoanDefaulted(uint256 _bidId) external view returns (bool);\n\n    /**\n     * @notice Checks to see if a borrower is delinquent.\n     * @param _bidId The id of the loan bid to check for.\n     */\n    function isPaymentLate(uint256 _bidId) external view returns (bool);\n\n    function getBidState(uint256 _bidId)\n        external\n        view\n        returns (TellerV2Storage.BidState);\n\n    function getBorrowerActiveLoanIds(address _borrower)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice Returns the borrower address for a given bid.\n     * @param _bidId The id of the bid/loan to get the borrower for.\n     * @return borrower_ The address of the borrower associated with the bid.\n     */\n    function getLoanBorrower(uint256 _bidId)\n        external\n        view\n        returns (address borrower_);\n\n    /**\n     * @notice Returns the lender address for a given bid.\n     * @param _bidId The id of the bid/loan to get the lender for.\n     * @return lender_ The address of the lender associated with the bid.\n     */\n    function getLoanLender(uint256 _bidId)\n        external\n        view\n        returns (address lender_);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/libraries/NumbersLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./WadRayMath.sol\";\n\n/**\n * @dev Utility library for uint256 numbers\n *\n * @author develop@teller.finance\n */\nlibrary NumbersLib {\n    using WadRayMath for uint256;\n\n    /**\n     * @dev It represents 100% with 2 decimal places.\n     */\n    uint16 internal constant PCT_100 = 10000;\n\n    function percentFactor(uint256 decimals) internal pure returns (uint256) {\n        return 100 * (10**decimals);\n    }\n\n    /**\n     * @notice Returns a percentage value of a number.\n     * @param self The number to get a percentage of.\n     * @param percentage The percentage value to calculate with 2 decimal places (10000 = 100%).\n     */\n    function percent(uint256 self, uint16 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return percent(self, percentage, 2);\n    }\n\n    /**\n     * @notice Returns a percentage value of a number.\n     * @param self The number to get a percentage of.\n     * @param percentage The percentage value to calculate with.\n     * @param decimals The number of decimals the percentage value is in.\n     */\n    function percent(\n        uint256 self,\n        uint256 percentage,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        return (self * percentage) / percentFactor(decimals);\n    }\n\n    /**\n     * @notice it returns the absolute number of a specified parameter\n     * @param self the number to be returned in it's absolute\n     * @return the absolute number\n     */\n    function abs(int256 self) internal pure returns (uint256) {\n        return self >= 0 ? uint256(self) : uint256(-1 * self);\n    }\n\n    /**\n     * @notice Returns a ratio percentage of {num1} to {num2}.\n     * @dev Returned value is type uint16.\n     * @param num1 The number used to get the ratio for.\n     * @param num2 The number used to get the ratio from.\n     * @return Ratio percentage with 2 decimal places (10000 = 100%).\n     */\n    function ratioOf(uint256 num1, uint256 num2)\n        internal\n        pure\n        returns (uint16)\n    {\n        return SafeCast.toUint16(ratioOf(num1, num2, 2));\n    }\n\n    /**\n     * @notice Returns a ratio percentage of {num1} to {num2}.\n     * @param num1 The number used to get the ratio for.\n     * @param num2 The number used to get the ratio from.\n     * @param decimals The number of decimals the percentage value is returned in.\n     * @return Ratio percentage value.\n     */\n    function ratioOf(\n        uint256 num1,\n        uint256 num2,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        if (num2 == 0) return 0;\n        return (num1 * percentFactor(decimals)) / num2;\n    }\n\n    /**\n     * @notice Calculates the payment amount for a cycle duration.\n     *  The formula is calculated based on the standard Estimated Monthly Installment (https://en.wikipedia.org/wiki/Equated_monthly_installment)\n     *  EMI = [P x R x (1+R)^N]/[(1+R)^N-1]\n     * @param principal The starting amount that is owed on the loan.\n     * @param loanDuration The length of the loan.\n     * @param cycleDuration The length of the loan's payment cycle.\n     * @param apr The annual percentage rate of the loan.\n     */\n    function pmt(\n        uint256 principal,\n        uint32 loanDuration,\n        uint32 cycleDuration,\n        uint16 apr\n    ) internal pure returns (uint256) {\n        uint256 n = loanDuration / cycleDuration;\n        if (apr == 0) return (principal / n);\n\n        uint256 one = WadRayMath.wad();\n        uint256 r = WadRayMath.pctToWad(apr).wadMul(cycleDuration).wadDiv(\n            365 days\n        );\n        uint256 exp = (one + r).wadPow(n);\n        uint256 numerator = principal.wadMul(r).wadMul(exp);\n        uint256 denominator = exp - one;\n\n        return numerator.wadDiv(denominator);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/libraries/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title WadRayMath library\n * @author Multiplier Finance\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n */\nlibrary WadRayMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant halfWAD = WAD / 2;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant halfRAY = RAY / 2;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n    uint256 internal constant PCT_WAD_RATIO = 1e14;\n    uint256 internal constant PCT_RAY_RATIO = 1e23;\n\n    function ray() internal pure returns (uint256) {\n        return RAY;\n    }\n\n    function wad() internal pure returns (uint256) {\n        return WAD;\n    }\n\n    function halfRay() internal pure returns (uint256) {\n        return halfRAY;\n    }\n\n    function halfWad() internal pure returns (uint256) {\n        return halfWAD;\n    }\n\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return halfWAD.add(a.mul(b)).div(WAD);\n    }\n\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        return halfB.add(a.mul(WAD)).div(b);\n    }\n\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return halfRAY.add(a.mul(b)).div(RAY);\n    }\n\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        return halfB.add(a.mul(RAY)).div(b);\n    }\n\n    function rayToWad(uint256 a) internal pure returns (uint256) {\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\n\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\n    }\n\n    function rayToPct(uint256 a) internal pure returns (uint16) {\n        uint256 halfRatio = PCT_RAY_RATIO / 2;\n\n        uint256 val = halfRatio.add(a).div(PCT_RAY_RATIO);\n        return SafeCast.toUint16(val);\n    }\n\n    function wadToPct(uint256 a) internal pure returns (uint16) {\n        uint256 halfRatio = PCT_WAD_RATIO / 2;\n\n        uint256 val = halfRatio.add(a).div(PCT_WAD_RATIO);\n        return SafeCast.toUint16(val);\n    }\n\n    function wadToRay(uint256 a) internal pure returns (uint256) {\n        return a.mul(WAD_RAY_RATIO);\n    }\n\n    function pctToRay(uint16 a) internal pure returns (uint256) {\n        return uint256(a).mul(RAY).div(1e4);\n    }\n\n    function pctToWad(uint16 a) internal pure returns (uint256) {\n        return uint256(a).mul(WAD).div(1e4);\n    }\n\n    /**\n     * @dev calculates base^duration. The code uses the ModExp precompile\n     * @return z base^duration, in ray\n     */\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256) {\n        return _pow(x, n, RAY, rayMul);\n    }\n\n    function wadPow(uint256 x, uint256 n) internal pure returns (uint256) {\n        return _pow(x, n, WAD, wadMul);\n    }\n\n    function _pow(\n        uint256 x,\n        uint256 n,\n        uint256 p,\n        function(uint256, uint256) internal pure returns (uint256) mul\n    ) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : p;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = mul(x, x);\n\n            if (n % 2 != 0) {\n                z = mul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/tests/V2Calculations_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./Testable.sol\";\nimport \"../TellerV2.sol\";\n\ncontract V2Calculations_Test is Testable {\n    using Arrays for uint256[];\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    TellerV2.Bid __bid;\n    EnumerableSet.UintSet cyclesToSkip;\n    uint256[] cyclesWithExtraPayments;\n    uint256[] cyclesWithExtraPaymentsAmounts;\n\n    constructor() {\n        __bid.loanDetails.principal = 100000e6; // 100k\n        __bid.loanDetails.loanDuration = 365 days * 3; // 3 years\n        __bid.terms.paymentCycle = 365 days / 12; // 1 month\n        __bid.terms.APR = 1000; // 10.0%\n    }\n\n    function setup_beforeAll() public {\n        delete cyclesToSkip;\n        delete cyclesWithExtraPayments;\n        delete cyclesWithExtraPaymentsAmounts;\n    }\n\n    function _01_calculateAmountOwed_test() public {\n        cyclesToSkip.add(2);\n        cyclesWithExtraPayments = [3, 4];\n        cyclesWithExtraPaymentsAmounts = [25000e6, 25000e6];\n\n        calculateAmountOwed_runner(18);\n    }\n\n    function _02_calculateAmountOwed_test() public {\n        cyclesToSkip.add(3);\n        cyclesToSkip.add(4);\n\n        calculateAmountOwed_runner(37);\n    }\n\n    function _03_calculateAmountOwed_test() public {\n        cyclesWithExtraPayments = [3, 7];\n        cyclesWithExtraPaymentsAmounts = [35000e6, 20000e6];\n\n        calculateAmountOwed_runner(16);\n    }\n\n    function calculateAmountOwed_runner(uint256 expectedTotalCycles) private {\n        // Calculate payment cycle amount\n        uint256 paymentCycleAmount = NumbersLib.pmt(\n            __bid.loanDetails.principal,\n            __bid.loanDetails.loanDuration,\n            __bid.terms.paymentCycle,\n            __bid.terms.APR\n        );\n        // Set the bid's payment cycle amount\n        __bid.terms.paymentCycleAmount = paymentCycleAmount;\n        // Set accepted bid timestamp to now\n        __bid.loanDetails.acceptedTimestamp = uint32(block.timestamp);\n\n        uint256 nowTimestamp = block.timestamp;\n        uint256 missedCycleExtraAmount;\n        uint256 owedPrincipal = __bid.loanDetails.principal;\n        uint256 cycleCount = Math.ceilDiv(\n            __bid.loanDetails.loanDuration,\n            __bid.terms.paymentCycle\n        );\n        uint256 cycleIndex;\n        while (owedPrincipal > 0) {\n            // Increment cycle index\n            cycleIndex++;\n\n            // Increase timestamp\n            nowTimestamp += __bid.terms.paymentCycle;\n\n            uint256 duePrincipal;\n            uint256 interest;\n            (owedPrincipal, duePrincipal, interest) = V2Calculations\n                .calculateAmountOwed(__bid, nowTimestamp);\n\n            // Check if we should skip this cycle for payments\n            if (cyclesToSkip.length() > 0) {\n                if (cyclesToSkip.contains(cycleIndex)) {\n                    // Add this cycle's payment amount to the next cycle's expected payment\n                    missedCycleExtraAmount += paymentCycleAmount;\n                    continue;\n                }\n            }\n\n            Test.eq(\n                duePrincipal + interest <=\n                    paymentCycleAmount + missedCycleExtraAmount,\n                true,\n                \"Payment amount greater than expected\"\n            );\n            // Reset missed cycle extra amount value\n            missedCycleExtraAmount = 0;\n\n            uint256 extraPaymentAmount;\n            // Add additional payment amounts for cycles\n            if (cyclesWithExtraPayments.length > 0) {\n                uint256 index = cyclesWithExtraPayments.findUpperBound(\n                    cycleIndex\n                );\n                if (\n                    index < cyclesWithExtraPayments.length &&\n                    cyclesWithExtraPayments[index] == cycleIndex\n                ) {\n                    extraPaymentAmount = cyclesWithExtraPaymentsAmounts[index];\n                }\n            }\n\n            // Mark repayment amounts\n            uint256 principalPayment = duePrincipal + extraPaymentAmount;\n            __bid.loanDetails.totalRepaid.principal += principalPayment;\n            __bid.loanDetails.totalRepaid.interest += interest;\n            // Subtract principal owed for while loop execution check\n            owedPrincipal -= principalPayment;\n\n            // Set last repaid time\n            __bid.loanDetails.lastRepaidTimestamp = uint32(nowTimestamp);\n        }\n\n        Test.eq(\n            cycleIndex,\n            expectedTotalCycles,\n            \"Expected number of cycles incorrect\"\n        );\n        Test.eq(\n            cycleIndex <= cycleCount + 1,\n            true,\n            \"Payment cycle exceeded agreed terms\"\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
    },
    "contracts/tests/PMT_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./Testable.sol\";\nimport \"../TellerV2.sol\";\n\ncontract PMT_Test is Testable, TellerV2 {\n    Bid __bid;\n\n    constructor() TellerV2(address(0)) {}\n\n    function _01_pmt_test() public {\n        __bid.loanDetails.principal = 10000e6; // 10k USDC\n        __bid.loanDetails.loanDuration = 365 days * 3; // 3 years\n        __bid.terms.paymentCycle = 365 days / 12; // 1 month\n        __bid.terms.APR = 300; // 3.0%\n        pmt_runner(290812096);\n    }\n\n    function _02_pmt_test() public {\n        __bid.loanDetails.principal = 100000e6; // 100x USDC\n        __bid.loanDetails.loanDuration = 365 days * 10; // 10 years\n        __bid.terms.paymentCycle = 365 days / 12; // 1 month\n        __bid.terms.APR = 800; // 8.0%\n        pmt_runner(1213275944);\n    }\n\n    function _03_pmt_test() public {\n        __bid.loanDetails.principal = 100000e6; // 100x USDC\n        __bid.loanDetails.loanDuration = 365 days * 10; // 10 years\n        __bid.terms.paymentCycle = 365 days / 12; // 1 month\n        __bid.terms.APR = 0; // 0.0%\n        pmt_runner(833333333);\n    }\n\n    function pmt_runner(uint256 _expected) private {\n        uint256 pmt = NumbersLib.pmt(\n            __bid.loanDetails.principal,\n            __bid.loanDetails.loanDuration,\n            __bid.terms.paymentCycle,\n            __bid.terms.APR\n        );\n        Test.eq(pmt, _expected, \"Loan payment for cycle incorrect\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/type-imports.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n//SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n"
    },
    "contracts/tests/resolvers/TestERC20Token.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20Token is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _totalSupply\n    ) ERC20(_name, _symbol) {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/TLR.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TLR is ERC20Votes, Ownable {\n    uint224 private immutable MAX_SUPPLY;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor(uint224 _supplyCap, address tokenOwner)\n        ERC20(\"Teller\", \"TLR\")\n        ERC20Permit(\"Teller\")\n    {\n        require(_supplyCap > 0, \"ERC20Capped: cap is 0\");\n        MAX_SUPPLY = _supplyCap;\n        _transferOwnership(tokenOwner);\n    }\n\n    /**\n     * @dev Max supply has been overridden to cap the token supply upon initialization of the contract\n     * @dev See OpenZeppelin's implementation of ERC20Votes _mint() function\n     */\n    function _maxSupply() internal view override returns (uint224) {\n        return MAX_SUPPLY;\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function mint(address account, uint256 amount) external onlyOwner {\n        _mint(account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function burn(address account, uint256 amount) external onlyOwner {\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/MarketRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"./EAS/TellerAS.sol\";\nimport \"./EAS/TellerASResolver.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\n\n// Libraries\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract MarketRegistry is\n    IMarketRegistry,\n    Initializable,\n    Context,\n    TellerASResolver\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* Constant Variables */\n\n    TellerAS public immutable tellerAS;\n\n    /* Storage Variables */\n\n    struct Marketplace {\n        address owner;\n        string metadataURI;\n        uint16 marketplaceFeePercent; // 10000 is 100%\n        bool lenderAttestationRequired;\n        EnumerableSet.AddressSet verifiedLendersForMarket;\n        mapping(address => bytes32) lenderAttestationIds;\n        uint32 paymentCycleDuration; //unix time\n        uint32 paymentDefaultDuration; //unix time\n        uint32 bidExpirationTime; //unix time\n        bool borrowerAttestationRequired;\n        EnumerableSet.AddressSet verifiedBorrowersForMarket;\n        mapping(address => bytes32) borrowerAttestationIds;\n    }\n\n    bytes32 public lenderAttestationSchemaId;\n\n    mapping(uint256 => Marketplace) internal markets;\n    mapping(bytes32 => uint256) internal _uriToId;\n    uint256 public marketCount;\n    bytes32 private _attestingSchemaId;\n    bytes32 public borrowerAttestationSchemaId;\n\n    uint256 public version = 0;\n\n    mapping(uint256 => bool) private marketIsClosed;\n\n    /* Modifiers */\n\n    modifier ownsMarket(uint256 _marketId) {\n        require(markets[_marketId].owner == _msgSender(), \"Not the owner\");\n        _;\n    }\n\n    modifier withAttestingSchema(bytes32 schemaId) {\n        _attestingSchemaId = schemaId;\n        _;\n        _attestingSchemaId = bytes32(0);\n    }\n\n    /* Events */\n\n    event MarketCreated(address indexed owner, uint256 marketId);\n    event SetMarketURI(uint256 marketId, string uri);\n    event SetPaymentCycleDuration(uint256 marketId, uint32 duration);\n    event SetPaymentDefaultDuration(uint256 marketId, uint32 duration);\n    event SetBidExpirationTime(uint256 marketId, uint32 duration);\n    event SetMarketFee(uint256 marketId, uint16 feePct);\n    event LenderAttestation(uint256 marketId, address lender);\n    event BorrowerAttestation(uint256 marketId, address borrower);\n    event LenderRevocation(uint256 marketId, address lender);\n    event BorrowerRevocation(uint256 marketId, address borrower);\n    event MarketClosed(uint256 marketId);\n    event LenderExitMarket(uint256 marketId, address lender);\n    event BorrowerExitMarket(uint256 marketId, address borrower);\n\n    /* Constructor */\n\n    constructor(TellerAS _tellerAS) {\n        tellerAS = _tellerAS;\n    }\n\n    /* External Functions */\n\n    function initialize() external initializer {\n        lenderAttestationSchemaId = tellerAS.getASRegistry().register(\n            \"(uint256 marketId, address lenderAddress)\",\n            this\n        );\n\n        _setAttestationSchemaId();\n    }\n\n    /**\n     * @notice Sets the new borrowerAttestationSchemaId on upgrade\n     */\n    function onUpgrade() external {\n        require(version == 0, \"Contract already upgraded!\");\n        version++;\n        _setAttestationSchemaId();\n    }\n\n    function _setAttestationSchemaId() internal {\n        borrowerAttestationSchemaId = tellerAS.getASRegistry().register(\n            \"(uint256 marketId, address borrowerAddress)\",\n            this\n        );\n    }\n\n    /**\n     * @notice Creates a new market.\n     * @param _initialOwner Address who will initially own the market.\n     * @param _paymentCycleDuration Length of time in seconds before a bid's next payment is required to be made.\n     * @param _paymentDefaultDuration Length of time in seconds before a loan is considered in default for non-payment.\n     * @param _bidExpirationTime Length of time in seconds before pending bids expire.\n     * @param _requireLenderAttestation Boolean that indicates if lenders require attestation to join market.\n     * @param _requireBorrowerAttestation Boolean that indicates if borrowers require attestation to join market.\n     * @param _uri URI string to get metadata details about the market.\n     */\n    function createMarket(\n        address _initialOwner,\n        uint32 _paymentCycleDuration,\n        uint32 _paymentDefaultDuration,\n        uint32 _bidExpirationTime,\n        uint16 _feePercent,\n        bool _requireLenderAttestation,\n        bool _requireBorrowerAttestation,\n        string calldata _uri\n    ) external {\n        require(_initialOwner != address(0), \"Invalid owner address\");\n        // Increment market ID counter\n        uint256 marketId = ++marketCount;\n\n        // Set the market owner\n        markets[marketId].owner = _initialOwner;\n\n        setMarketURI(marketId, _uri);\n        setPaymentCycleDuration(marketId, _paymentCycleDuration);\n        setPaymentDefaultDuration(marketId, _paymentDefaultDuration);\n        setMarketFeePercent(marketId, _feePercent);\n        setBidExpirationTime(marketId, _bidExpirationTime);\n\n        // Check if market requires lender attestation to join\n        if (_requireLenderAttestation) {\n            markets[marketId].lenderAttestationRequired = true;\n        }\n        // Check if market requires borrower attestation to join\n        if (_requireBorrowerAttestation) {\n            markets[marketId].borrowerAttestationRequired = true;\n        }\n\n        emit MarketCreated(_initialOwner, marketId);\n    }\n\n    /**\n     * @notice Closes a market so new bids cannot be added.\n     * @param _marketId The market ID for the market to close.\n     */\n\n    function closeMarket(uint256 _marketId) public ownsMarket(_marketId) {\n        if (!marketIsClosed[_marketId]) {\n            marketIsClosed[_marketId] = true;\n\n            emit MarketClosed(_marketId);\n        }\n    }\n\n    /**\n     * @notice Returns the status of a market being open or closed for new bids.\n     * @param _marketId The market ID for the market to check.\n     */\n    function isMarketClosed(uint256 _marketId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return marketIsClosed[_marketId];\n    }\n\n    /**\n     * @notice Adds a lender to a market.\n     * @dev See {_attestStakeholder}.\n     */\n    function attestLender(\n        uint256 _marketId,\n        address _lenderAddress,\n        uint256 _expirationTime\n    ) external {\n        _attestStakeholder(_marketId, _lenderAddress, _expirationTime, true);\n    }\n\n    /**\n     * @notice Adds a lender to a market via delegated attestation.\n     * @dev See {_attestStakeholderViaDelegation}.\n     */\n    function attestLender(\n        uint256 _marketId,\n        address _lenderAddress,\n        uint256 _expirationTime,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        _attestStakeholderViaDelegation(_marketId, _lenderAddress, _expirationTime, true, _v, _r, _s);\n    }\n\n    /**\n     * @notice Removes a lender from an market.\n     * @dev See {_revokeStakeholder}.\n     */\n    function revokeLender(\n        uint256 _marketId,\n        address _lenderAddress\n    ) external {\n        _revokeStakeholder(_marketId, _lenderAddress, true);\n    }\n\n    /**\n     * @notice Removes a borrower from a market via delegated revocation.\n     * @dev See {_revokeStakeholderViaDelegation}.\n     */\n    function revokeLender(\n        uint256 _marketId,\n        address _lenderAddress,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        _revokeStakeholderViaDelegation(_marketId, _lenderAddress, true, _v, _r, _s);\n    }\n\n    /**\n     * @notice Allows a lender to voluntarily leave a market.\n     * @param _marketId The market ID to leave.\n     */\n    function lenderExitMarket(uint256 _marketId) external {\n        // Remove lender address from market set\n        bool response = markets[_marketId].verifiedLendersForMarket.remove(\n            _msgSender()\n        );\n        if (response) {\n            emit LenderExitMarket(_marketId, _msgSender());\n        }\n    }\n\n    /**\n     * @notice Adds a borrower to a market.\n     * @dev See {_attestStakeholder}.\n     */\n    function attestBorrower(\n        uint256 _marketId,\n        address _borrowerAddress,\n        uint256 _expirationTime\n    ) external {\n        _attestStakeholder(_marketId, _borrowerAddress, _expirationTime, false);\n    }\n\n    /**\n     * @notice Adds a borrower to a market via delegated attestation.\n     * @dev See {_attestStakeholderViaDelegation}.\n     */\n    function attestBorrower(\n        uint256 _marketId,\n        address _borrowerAddress,\n        uint256 _expirationTime,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        _attestStakeholderViaDelegation(_marketId, _borrowerAddress, _expirationTime, false, _v, _r, _s);\n    }\n\n    /**\n     * @notice Removes a borrower from an market.\n     * @dev See {_revokeStakeholder}.\n     */\n    function revokeBorrower(\n        uint256 _marketId,\n        address _borrowerAddress\n    ) external {\n        _revokeStakeholder(_marketId, _borrowerAddress, false);\n    }\n\n    /**\n     * @notice Removes a borrower from a market via delegated revocation.\n     * @dev See {_revokeStakeholderViaDelegation}.\n     */\n    function revokeBorrower(\n        uint256 _marketId,\n        address _borrowerAddress,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        _revokeStakeholderViaDelegation(_marketId, _borrowerAddress, false, _v, _r, _s);\n    }\n\n    /**\n     * @notice Allows a borrower to voluntarily leave a market.\n     * @param _marketId The market ID to leave.\n     */\n    function borrowerExitMarket(uint256 _marketId) external {\n        // Remove borrower address from market set\n        bool response = markets[_marketId].verifiedBorrowersForMarket.remove(\n            _msgSender()\n        );\n        if (response) {\n            emit BorrowerExitMarket(_marketId, _msgSender());\n        }\n    }\n\n    /**\n     * @notice Verifies an attestation is valid.\n     * @dev This function must only be called by the `attestLender` function above.\n     * @param recipient Lender's address who is being attested.\n     * @param schema The schema used for the attestation.\n     * @param data Data the must include the market ID and lender's address\n     * @param\n     * @param attestor Market owner's address who signed the attestation.\n     * @return Boolean indicating the attestation was successful.\n     */\n    function resolve(\n        address recipient,\n        bytes calldata schema,\n        bytes calldata data,\n        uint256, /* expirationTime */\n        address attestor\n    ) external payable override returns (bool) {\n        bytes32 attestationSchemaId = keccak256(\n            abi.encodePacked(schema, address(this))\n        );\n        (uint256 marketId, address lenderAddress) = abi.decode(\n            data,\n            (uint256, address)\n        );\n        return\n            _attestingSchemaId == attestationSchemaId &&\n            recipient == lenderAddress &&\n            attestor == markets[marketId].owner || attestor == address(this);\n    }\n\n    /**\n     * @notice Transfers ownership of a marketplace.\n     * @param _marketId The ID of a market.\n     * @param _newOwner Address of the new market owner.\n     *\n     * Requirements:\n     * - The caller must by the current owner.\n     */\n    function transferMarketOwnership(uint256 _marketId, address _newOwner)\n        public\n        ownsMarket(_marketId)\n    {\n        markets[_marketId].owner = _newOwner;\n    }\n\n    /**\n     * @notice Sets the metadata URI for a market.\n     * @param _marketId The ID of a market.\n     * @param _uri A URI that points to a market's metadata.\n     *\n     * Requirements:\n     * - The caller must by the current owner.\n     */\n    function setMarketURI(uint256 _marketId, string calldata _uri)\n        public\n        ownsMarket(_marketId)\n    {\n        // Check if URI is already used\n        bytes32 uriId = keccak256(abi.encode(_uri));\n        require(_uriToId[uriId] == 0, \"non-unique market URI\");\n\n        // Update market counter & store reverse lookup\n        _uriToId[uriId] = _marketId;\n        markets[_marketId].metadataURI = _uri;\n\n        emit SetMarketURI(_marketId, _uri);\n    }\n\n    /**\n     * @notice Sets the duration of new loans for this market before they turn delinquent.\n     * @notice Changing this value does not change the terms of existing loans for this market.\n     * @param _marketId The ID of a market.\n     * @param _duration Delinquency duration for new loans\n     */\n    function setPaymentCycleDuration(uint256 _marketId, uint32 _duration)\n        public\n        ownsMarket(_marketId)\n    {\n        markets[_marketId].paymentCycleDuration = _duration;\n\n        emit SetPaymentCycleDuration(_marketId, _duration);\n    }\n\n    /**\n     * @notice Sets the duration of new loans for this market before they turn defaulted.\n     * @notice Changing this value does not change the terms of existing loans for this market.\n     * @param _marketId The ID of a market.\n     * @param _duration Default duration for new loans\n     */\n    function setPaymentDefaultDuration(uint256 _marketId, uint32 _duration)\n        public\n        ownsMarket(_marketId)\n    {\n        markets[_marketId].paymentDefaultDuration = _duration;\n\n        emit SetPaymentDefaultDuration(_marketId, _duration);\n    }\n\n    function setBidExpirationTime(uint256 marketId, uint32 duration)\n        public\n        ownsMarket(marketId)\n    {\n        markets[marketId].bidExpirationTime = duration;\n\n        emit SetBidExpirationTime(marketId, duration);\n    }\n\n    /**\n     * @notice Sets the fee for the market.\n     * @param _marketId The ID of a market.\n     * @param _newPercent The percentage fee in basis points.\n     *\n     * Requirements:\n     * - The caller must by the current owner.\n     */\n    function setMarketFeePercent(uint256 _marketId, uint16 _newPercent)\n        public\n        ownsMarket(_marketId)\n    {\n        require(_newPercent >= 0 && _newPercent <= 10000, \"invalid percent\");\n        markets[_marketId].marketplaceFeePercent = _newPercent;\n        emit SetMarketFee(_marketId, _newPercent);\n    }\n\n    /**\n     * @notice Gets the data associated with a market.\n     * @param _marketId The ID of a market.\n     */\n    function getMarketData(uint256 _marketId)\n        public\n        view\n        returns (\n            address owner,\n            uint32 paymentCycleDuration,\n            uint32 paymentDefaultDuration,\n            uint32 loanExpirationTime,\n            string memory metadataURI,\n            uint16 marketplaceFeePercent,\n            bool lenderAttestationRequired\n        )\n    {\n        return (\n            markets[_marketId].owner,\n            markets[_marketId].paymentCycleDuration,\n            markets[_marketId].paymentDefaultDuration,\n            markets[_marketId].bidExpirationTime,\n            markets[_marketId].metadataURI,\n            markets[_marketId].marketplaceFeePercent,\n            markets[_marketId].lenderAttestationRequired\n        );\n    }\n\n    /**\n     * @notice Gets the attestation requirements for a given market.\n     * @param _marketId The ID of the market.\n     */\n    function getMarketAttestationRequirements(uint256 _marketId)\n        public\n        view\n        returns (\n            bool lenderAttestationRequired,\n            bool borrowerAttestationRequired\n        )\n    {\n        return (\n            markets[_marketId].lenderAttestationRequired,\n            markets[_marketId].borrowerAttestationRequired\n        );\n    }\n\n    /**\n     * @notice Gets the address of a market's owner.\n     * @param _marketId The ID of a market.\n     * @return The address of a market's owner.\n     */\n    function getMarketOwner(uint256 _marketId)\n        public\n        view\n        override\n        returns (address)\n    {\n        return markets[_marketId].owner;\n    }\n\n    /**\n     * @notice Gets the metadata URI of a market.\n     * @param _marketId The ID of a market.\n     * @return URI of a market's metadata.\n     */\n    function getMarketURI(uint256 _marketId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        return markets[_marketId].metadataURI;\n    }\n\n    /**\n     * @notice Gets the loan delinquent duration of a market.\n     * @param _marketId The ID of a market.\n     * @return Duration of a loan until it is delinquent.\n     */\n    function getPaymentCycleDuration(uint256 _marketId)\n        public\n        view\n        override\n        returns (uint32)\n    {\n        return markets[_marketId].paymentCycleDuration;\n    }\n\n    /**\n     * @notice Gets the loan default duration of a market.\n     * @param _marketId The ID of a market.\n     * @return Duration of a loan repayment interval until it is default.\n     */\n    function getPaymentDefaultDuration(uint256 _marketId)\n        public\n        view\n        override\n        returns (uint32)\n    {\n        return markets[_marketId].paymentDefaultDuration;\n    }\n\n    function getBidExpirationTime(uint256 marketId)\n        public\n        view\n        override\n        returns (uint32)\n    {\n        return markets[marketId].bidExpirationTime;\n    }\n\n    /**\n     * @notice Gets the marketplace fee in basis points\n     * @param _marketId The ID of a market.\n     * @return fee in basis points\n     */\n    function getMarketplaceFee(uint256 _marketId)\n        public\n        view\n        override\n        returns (uint16 fee)\n    {\n        return markets[_marketId].marketplaceFeePercent;\n    }\n\n    /**\n     * @notice Checks if a lender has been attested and added to a market.\n     * @param _marketId The ID of a market.\n     * @param _lenderAddress Address to check.\n     * @return isVerified_ Boolean indicating if a lender has been added to a market.\n     * @return uuid_ Bytes32 representing the UUID of the lender.\n     */\n    function isVerifiedLender(uint256 _marketId, address _lenderAddress)\n        public\n        view\n        override\n        returns (bool isVerified_, bytes32 uuid_)\n    {\n        return\n            _isVerified(\n                _lenderAddress,\n                markets[_marketId].lenderAttestationRequired,\n                markets[_marketId].lenderAttestationIds,\n                markets[_marketId].verifiedLendersForMarket\n            );\n    }\n\n    /**\n     * @notice Checks if a borrower has been attested and added to a market.\n     * @param _marketId The ID of a market.\n     * @param _borrowerAddress Address of the borrower to check.\n     * @return isVerified_ Boolean indicating if a borrower has been added to a market.\n     * @return uuid_ Bytes32 representing the UUID of the borrower.\n     */\n    function isVerifiedBorrower(uint256 _marketId, address _borrowerAddress)\n        public\n        view\n        override\n        returns (bool isVerified_, bytes32 uuid_)\n    {\n        return\n            _isVerified(\n                _borrowerAddress,\n                markets[_marketId].borrowerAttestationRequired,\n                markets[_marketId].borrowerAttestationIds,\n                markets[_marketId].verifiedBorrowersForMarket\n            );\n    }\n\n    /**\n     * @notice Gets addresses of all attested lenders.\n     * @param _marketId The ID of a market.\n     * @param _page Page index to start from.\n     * @param _perPage Number of items in a page to return.\n     * @return Array of addresses that have been added to a market.\n     */\n    function getAllVerifiedLendersForMarket(\n        uint256 _marketId,\n        uint256 _page,\n        uint256 _perPage\n    ) public view returns (address[] memory) {\n        EnumerableSet.AddressSet storage set = markets[_marketId]\n            .verifiedLendersForMarket;\n\n        return _getStakeholdersForMarket(set, _page, _perPage);\n    }\n\n    /**\n     * @notice Gets addresses of all attested borrowers.\n     * @param _marketId The ID of the market.\n     * @param _page Page index to start from.\n     * @param _perPage Number of items in a page to return.\n     * @return Array of addresses that have been added to a market.\n     */\n    function getAllVerifiedBorrowersForMarket(\n        uint256 _marketId,\n        uint256 _page,\n        uint256 _perPage\n    ) public view returns (address[] memory) {\n        EnumerableSet.AddressSet storage set = markets[_marketId]\n            .verifiedBorrowersForMarket;\n        return _getStakeholdersForMarket(set, _page, _perPage);\n    }\n\n    /**\n     * @notice Gets addresses of all attested relevant stakeholders.\n     * @param _set The stored set of stakeholders to index from.\n     * @param _page Page index to start from.\n     * @param _perPage Number of items in a page to return.\n     * @return stakeholders_ Array of addresses that have been added to a market.\n     */\n    function _getStakeholdersForMarket(\n        EnumerableSet.AddressSet storage _set,\n        uint256 _page,\n        uint256 _perPage\n    ) internal view returns (address[] memory stakeholders_) {\n        uint256 len = _set.length();\n\n        uint256 start = _page * _perPage;\n        if (start <= len) {\n            uint256 end = start + _perPage;\n            // Ensure we do not go out of bounds\n            if (end > len) {\n                end = len;\n            }\n\n            stakeholders_ = new address[](end - start);\n            for (uint256 i = start; i < end; i++) {\n                stakeholders_[i] = _set.at(i);\n            }\n        }\n    }\n\n    /* Internal Functions */\n\n    /**\n     * @notice Sets the metadata URI for a market.\n     * @param _marketId The ID of a market.\n     * @param _uri A URI that points to a market's metadata.\n     */\n    function _setMarketUri(uint256 _marketId, string calldata _uri) internal {\n        require(_marketId > 0, \"Market ID 0\");\n\n        // Check if URI is already used\n        bytes32 uriId = keccak256(abi.encode(_uri));\n        require(_uriToId[uriId] == 0, \"non-unique market URI\");\n\n        // Update market counter & store reverse lookup\n        _uriToId[uriId] = _marketId;\n        markets[_marketId].metadataURI = _uri;\n\n        emit SetMarketURI(_marketId, _uri);\n    }\n\n    /**\n     * @notice Adds a stakeholder (lender or borrower) to a market.\n     * @param _marketId The market ID to add a borrower to.\n     * @param _stakeholderAddress The address of the stakeholder to add to the market.\n     * @param _expirationTime The expiration time of the attestation.\n     * @param _expirationTime The expiration time of the attestation.\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\n     */\n    function _attestStakeholder(\n        uint256 _marketId,\n        address _stakeholderAddress,\n        uint256 _expirationTime,\n        bool _isLender\n    ) internal withAttestingSchema(_isLender ? lenderAttestationSchemaId : borrowerAttestationSchemaId) {\n        require(_msgSender() == markets[_marketId].owner, \"Not the market owner\");\n\n        // Submit attestation for borrower to join a market\n        bytes32 uuid = tellerAS.attest(\n            _stakeholderAddress,\n            _attestingSchemaId, // set by the modifier\n            _expirationTime,\n            0,\n            abi.encode(_marketId, _stakeholderAddress)\n        );\n        _attestStakeholderVerification(_marketId, _stakeholderAddress, uuid, _isLender);\n    }\n\n    /**\n     * @notice Adds a stakeholder (lender or borrower) to a market via delegated attestation.\n     * @dev The signature must match that of the market owner.\n     * @param _marketId The market ID to add a lender to.\n     * @param _stakeholderAddress The address of the lender to add to the market.\n     * @param _expirationTime The expiration time of the attestation.\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\n     * @param _v Signature value\n     * @param _r Signature value\n     * @param _s Signature value\n     */\n    function _attestStakeholderViaDelegation(\n        uint256 _marketId,\n        address _stakeholderAddress,\n        uint256 _expirationTime,\n        bool _isLender,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal withAttestingSchema(_isLender ? lenderAttestationSchemaId : borrowerAttestationSchemaId) {\n        // NOTE: block scope to prevent stack too deep!\n        bytes32 uuid;\n        {\n            bytes memory data = abi.encode(_marketId, _stakeholderAddress);\n            address attestor = markets[_marketId].owner;\n            // Submit attestation for stakeholder to join a market (attestation must be signed by market owner)\n            uuid = tellerAS.attestByDelegation(\n                _stakeholderAddress,\n                _attestingSchemaId, // set by the modifier\n                _expirationTime,\n                0,\n                data,\n                attestor,\n                _v,\n                _r,\n                _s\n            );\n        }\n        _attestStakeholderVerification(_marketId, _stakeholderAddress, uuid, _isLender);\n    }\n\n    /**\n     * @notice Adds a stakeholder (borrower/lender) to a market.\n     * @param _marketId The market ID to add a stakeholder to.\n     * @param _stakeholderAddress The address of the stakeholder to add to the market.\n     * @param _uuid The UUID of the attestation created.\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\n     */\n    function _attestStakeholderVerification(\n        uint256 _marketId,\n        address _stakeholderAddress,\n        bytes32 _uuid,\n        bool _isLender\n    ) internal {\n        if (_isLender) {\n            // Store the lender attestation ID for the market ID\n            markets[_marketId].lenderAttestationIds[_stakeholderAddress] = _uuid;\n            // Add lender address to market set\n            markets[_marketId].verifiedLendersForMarket.add(_stakeholderAddress);\n\n            emit LenderAttestation(_marketId, _stakeholderAddress);\n        } else {\n            // Store the lender attestation ID for the market ID\n            markets[_marketId].borrowerAttestationIds[_stakeholderAddress] = _uuid;\n            // Add lender address to market set\n            markets[_marketId].verifiedBorrowersForMarket.add(_stakeholderAddress);\n\n            emit BorrowerAttestation(_marketId, _stakeholderAddress);\n        }\n    }\n\n    /**\n     * @notice Removes a stakeholder from an market.\n     * @dev The caller must be the market owner.\n     * @param _marketId The market ID to remove the borrower from.\n     * @param _stakeholderAddress The address of the borrower to remove from the market.\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\n     */\n    function _revokeStakeholder(\n        uint256 _marketId,\n        address _stakeholderAddress,\n        bool _isLender\n    ) internal {\n        require(_msgSender() == markets[_marketId].owner, \"Not the market owner\");\n\n        bytes32 uuid = _revokeStakeholderVerification(_marketId, _stakeholderAddress, _isLender);\n        // NOTE: Disabling the call to revoke the attestation on EAS contracts\n//        tellerAS.revoke(uuid);\n    }\n\n    /**\n     * @notice Removes a stakeholder from an market via delegated revocation.\n     * @param _marketId The market ID to remove the borrower from.\n     * @param _stakeholderAddress The address of the borrower to remove from the market.\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\n     * @param _v Signature value\n     * @param _r Signature value\n     * @param _s Signature value\n     */\n    function _revokeStakeholderViaDelegation(\n        uint256 _marketId,\n        address _stakeholderAddress,\n        bool _isLender,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        bytes32 uuid = _revokeStakeholderVerification(_marketId, _stakeholderAddress, _isLender);\n        // NOTE: Disabling the call to revoke the attestation on EAS contracts\n//        address attestor = markets[_marketId].owner;\n//        tellerAS.revokeByDelegation(uuid, attestor, _v, _r, _s);\n    }\n\n    /**\n     * @notice Removes a stakeholder (borrower/lender) from a market.\n     * @param _marketId The market ID to remove the lender from.\n     * @param _stakeholderAddress The address of the stakeholder to remove from the market.\n     * @param _isLender Boolean indicating if the stakeholder is a lender. Otherwise it is a borrower.\n     * @return uuid_ The ID of the previously verified attestation.\n     */\n    function _revokeStakeholderVerification(\n        uint256 _marketId,\n        address _stakeholderAddress,\n        bool _isLender\n    ) internal returns (bytes32 uuid_) {\n        if (_isLender) {\n            uuid_ = markets[_marketId].lenderAttestationIds[_stakeholderAddress];\n            // Remove lender address from market set\n            markets[_marketId].verifiedLendersForMarket.remove(_stakeholderAddress);\n\n            emit LenderRevocation(_marketId, _stakeholderAddress);\n        } else {\n            uuid_ = markets[_marketId].borrowerAttestationIds[_stakeholderAddress];\n            // Remove borrower address from market set\n            markets[_marketId].verifiedBorrowersForMarket.remove(_stakeholderAddress);\n\n            emit BorrowerRevocation(_marketId, _stakeholderAddress);\n        }\n    }\n\n    /**\n     * @notice Checks if a stakeholder has been attested and added to a market.\n     * @param _stakeholderAddress Address of the stakeholder to check.\n     * @param _attestationRequired Stored boolean indicating if attestation is required for the stakeholder class.\n     * @param _stakeholderAttestationIds Mapping of attested Ids for the stakeholder class.\n     */\n    function _isVerified(\n        address _stakeholderAddress,\n        bool _attestationRequired,\n        mapping(address => bytes32) storage _stakeholderAttestationIds,\n        EnumerableSet.AddressSet storage _verifiedStakeholderForMarket\n    ) internal view returns (bool isVerified_, bytes32 uuid_) {\n        if (_attestationRequired) {\n            isVerified_ =\n                _verifiedStakeholderForMarket.contains(_stakeholderAddress) &&\n                tellerAS.isAttestationActive(\n                    _stakeholderAttestationIds[_stakeholderAddress]\n                );\n            uuid_ = _stakeholderAttestationIds[_stakeholderAddress];\n        } else {\n            isVerified_ = true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "contracts/ReputationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// Interfaces\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract ReputationManager is IReputationManager, Initializable {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    bytes32 public constant CONTROLLER = keccak256(\"CONTROLLER\");\n\n    ITellerV2 public tellerV2;\n    mapping(address => EnumerableSet.UintSet) private _delinquencies;\n    mapping(address => EnumerableSet.UintSet) private _defaults;\n    mapping(address => EnumerableSet.UintSet) private _currentDelinquencies;\n    mapping(address => EnumerableSet.UintSet) private _currentDefaults;\n\n    event MarkAdded(\n        address indexed account,\n        RepMark indexed repMark,\n        uint256 bidId\n    );\n    event MarkRemoved(\n        address indexed account,\n        RepMark indexed repMark,\n        uint256 bidId\n    );\n\n    /**\n     * @notice Initializes the proxy.\n     */\n    function initialize(address _tellerV2) external initializer {\n        tellerV2 = ITellerV2(_tellerV2);\n    }\n\n    function getDelinquentLoanIds(address _account)\n        public\n        override\n        returns (uint256[] memory)\n    {\n        updateAccountReputation(_account);\n        return _delinquencies[_account].values();\n    }\n\n    function getDefaultedLoanIds(address _account)\n        public\n        override\n        returns (uint256[] memory)\n    {\n        updateAccountReputation(_account);\n        return _defaults[_account].values();\n    }\n\n    function getCurrentDelinquentLoanIds(address _account)\n        public\n        override\n        returns (uint256[] memory)\n    {\n        updateAccountReputation(_account);\n        return _currentDelinquencies[_account].values();\n    }\n\n    function getCurrentDefaultLoanIds(address _account)\n        public\n        override\n        returns (uint256[] memory)\n    {\n        updateAccountReputation(_account);\n        return _currentDefaults[_account].values();\n    }\n\n    function updateAccountReputation(address _account) public override {\n        uint256[] memory activeBidIds = tellerV2.getBorrowerActiveLoanIds(\n            _account\n        );\n        for (uint256 i; i < activeBidIds.length; i++) {\n            _applyReputation(_account, activeBidIds[i]);\n        }\n    }\n\n    function updateAccountReputation(address _account, uint256 _bidId)\n        public\n        override\n        returns (RepMark)\n    {\n        return _applyReputation(_account, _bidId);\n    }\n\n    function _applyReputation(address _account, uint256 _bidId)\n        internal\n        returns (RepMark mark_)\n    {\n        mark_ = RepMark.Good;\n\n        if (tellerV2.isLoanDefaulted(_bidId)) {\n            mark_ = RepMark.Default;\n\n            // Remove delinquent status\n            _removeMark(_account, _bidId, RepMark.Delinquent);\n        } else if (tellerV2.isPaymentLate(_bidId)) {\n            mark_ = RepMark.Delinquent;\n        }\n\n        // Mark status if not \"Good\"\n        if (mark_ != RepMark.Good) {\n            _addMark(_account, _bidId, mark_);\n        }\n    }\n\n    function _addMark(\n        address _account,\n        uint256 _bidId,\n        RepMark _mark\n    ) internal {\n        if (_mark == RepMark.Delinquent) {\n            _delinquencies[_account].add(_bidId);\n            _currentDelinquencies[_account].add(_bidId);\n        } else if (_mark == RepMark.Default) {\n            _defaults[_account].add(_bidId);\n            _currentDefaults[_account].add(_bidId);\n        }\n\n        emit MarkAdded(_account, _mark, _bidId);\n    }\n\n    function _removeMark(\n        address _account,\n        uint256 _bidId,\n        RepMark _mark\n    ) internal {\n        if (_mark == RepMark.Delinquent) {\n            _currentDelinquencies[_account].remove(_bidId);\n        } else if (_mark == RepMark.Default) {\n            _currentDefaults[_account].remove(_bidId);\n        }\n\n        emit MarkRemoved(_account, _mark, _bidId);\n    }\n}\n"
    },
    "contracts/tests/GetMetaDataURI_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\n\nimport \"./Testable.sol\";\nimport \"../TellerV2.sol\";\n\ncontract GetMetaDataURI_Test is Testable, TellerV2 {\n    constructor() TellerV2(address(0)) {}\n\n    function setup_beforeAll() public {\n        // Old depreciated _metadataURI on bid struct\n        bids[0]\n            ._metadataURI = 0x0000000000000000000000000000000086004f3f419f88be1cab574b4bd01b6d;\n        // New metadataURI from uris mapping\n        uris[59] = \"ipfs://QmMyDataHash\";\n    }\n\n    function getMetaDataURI_test() public {\n        string memory oldURI = getMetadataURI(0);\n        Test.eq(\n            oldURI,\n            \"0x0000000000000000000000000000000086004f3f419f88be1cab574b4bd01b6d\",\n            \"Expected URI does not match stored depreciated value in the Bid struct\"\n        );\n        string memory newURI = getMetadataURI(59);\n        Test.eq(\n            newURI,\n            \"ipfs://QmMyDataHash\",\n            \"Expected URI does not match new value in uri mapping\"\n        );\n    }\n}\n"
    },
    "contracts/TellerV2Mock.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"./TellerV2.sol\";\n\ncontract TellerV2Mock is TellerV2 {\n    constructor(address trustedForwarder) TellerV2(trustedForwarder) {}\n\n    function mockBid(Bid calldata _bid) external {\n        bids[bidId] = _bid;\n        borrowerBids[_msgSender()].push(bidId);\n        bidId++;\n    }\n\n    function mockAcceptedTimestamp(uint256 _bidId, uint32 _timestamp) external {\n        require(_timestamp > 0, \"Accepted timestamp 0\");\n        bids[_bidId].loanDetails.acceptedTimestamp = _timestamp;\n    }\n\n    function mockAcceptedTimestamp(uint256 _bidId) external {\n        bids[_bidId].loanDetails.acceptedTimestamp = uint32(block.timestamp);\n    }\n\n    function mockLastRepaidTimestamp(uint256 _bidId, uint32 _timestamp)\n        external\n    {\n        require(_timestamp > 0, \"Repaid timestamp 0\");\n        bids[_bidId].loanDetails.lastRepaidTimestamp = _timestamp;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/metatx/MinimalForwarderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (metatx/MinimalForwarder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.\n */\ncontract MinimalForwarderUpgradeable is Initializable, EIP712Upgradeable {\n    using ECDSAUpgradeable for bytes32;\n\n    struct ForwardRequest {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint256 nonce;\n        bytes data;\n    }\n\n    bytes32 private constant _TYPEHASH =\n        keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");\n\n    mapping(address => uint256) private _nonces;\n\n    function __MinimalForwarder_init() internal onlyInitializing {\n        __EIP712_init_unchained(\"MinimalForwarder\", \"0.0.1\");\n    }\n\n    function __MinimalForwarder_init_unchained() internal onlyInitializing {}\n\n    function getNonce(address from) public view returns (uint256) {\n        return _nonces[from];\n    }\n\n    function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\n        address signer = _hashTypedDataV4(\n            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\n        ).recover(signature);\n        return _nonces[req.from] == req.nonce && signer == req.from;\n    }\n\n    function execute(ForwardRequest calldata req, bytes calldata signature)\n        public\n        payable\n        returns (bool, bytes memory)\n    {\n        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");\n        _nonces[req.from] = req.nonce + 1;\n\n        (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(\n            abi.encodePacked(req.data, req.from)\n        );\n\n        // Validate that the relayer has sent enough gas for the call.\n        // See https://ronan.eth.link/blog/ethereum-gas-dangers/\n        if (gasleft() <= req.gas / 63) {\n            // We explicitly trigger invalid opcode to consume all gas and bubble-up the effects, since\n            // neither revert or assert consume all gas since Solidity 0.8.0\n            // https://docs.soliditylang.org/en/v0.8.0/control-structures.html#panic-via-assert-and-error-via-require\n            assembly {\n                invalid()\n            }\n        }\n\n        return (success, returndata);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/MetaForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/metatx/MinimalForwarderUpgradeable.sol\";\n\ncontract MetaForwarder is MinimalForwarderUpgradeable {\n    function initialize() external initializer {\n        __EIP712_init_unchained(\"TellerMetaForwarder\", \"0.0.1\");\n    }\n}\n"
    },
    "contracts/ProtocolFeeMock.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"./ProtocolFee.sol\";\n\ncontract ProtocolFeeMock is ProtocolFee {\n    bool public setProtocolFeeCalled;\n\n    function initialize(uint16 _initFee) external initializer {\n        __ProtocolFee_init(_initFee);\n    }\n\n    function setProtocolFee(uint16 newFee) public override onlyOwner {\n        setProtocolFeeCalled = true;\n\n        bool _isInitializing;\n        assembly {\n            _isInitializing := sload(1)\n        }\n\n        // Only call the actual function if we are not initializing\n        if (!_isInitializing) {\n            super.setProtocolFee(newFee);\n        }\n    }\n}\n"
    },
    "contracts/tests/resolvers/TestASRecipientResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../../EAS/TellerASResolver.sol\";\n\n/**\n * @title A sample AS resolver that checks whether the attestation is to a specific recipient.\n */\ncontract TestASRecipientResolver is TellerASResolver {\n    address private immutable _targetRecipient;\n\n    constructor(address targetRecipient) {\n        _targetRecipient = targetRecipient;\n    }\n\n    function resolve(\n        address recipient,\n        bytes calldata, /* schema */\n        bytes calldata, /* data */\n        uint256, /* expirationTime */\n        address /* msgSender */\n    ) external payable virtual override returns (bool) {\n        return recipient == _targetRecipient;\n    }\n}\n"
    },
    "contracts/tests/resolvers/TestASPayingResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../../EAS/TellerASResolver.sol\";\n\n/**\n * @title A sample AS resolver that pays attesters\n */\ncontract TestASPayingResolver is TellerASResolver {\n    uint256 private immutable _incentive;\n\n    constructor(uint256 incentive) {\n        _incentive = incentive;\n    }\n\n    function isPayable() public pure override returns (bool) {\n        return true;\n    }\n\n    function resolve(\n        address recipient,\n        bytes calldata, /* schema */\n        bytes calldata, /* data */\n        uint256, /* expirationTime */\n        address /* msgSender */\n    ) external payable virtual override returns (bool) {\n        payable(recipient).transfer(_incentive);\n\n        return true;\n    }\n}\n"
    },
    "contracts/tests/resolvers/TestASExpirationTimeResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../../EAS/TellerASResolver.sol\";\n\n/**\n * @title A sample AS resolver that checks whether the expiration time is later than a specific timestamp.\n */\ncontract TestASExpirationTimeResolver is TellerASResolver {\n    uint256 private immutable _validAfter;\n\n    constructor(uint256 validAfter) {\n        _validAfter = validAfter;\n    }\n\n    function resolve(\n        address, /* recipient */\n        bytes calldata, /* schema */\n        bytes calldata, /* data */\n        uint256 expirationTime,\n        address /* msgSender */\n    ) external payable virtual override returns (bool) {\n        return expirationTime >= _validAfter;\n    }\n}\n"
    },
    "contracts/tests/resolvers/TestASDataResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../../EAS/TellerASResolver.sol\";\n\n/**\n * @title A sample AS resolver that checks whether an attestation data is either \\x00 or \\x01.\n */\ncontract TestASDataResolver is TellerASResolver {\n    function resolve(\n        address, /* recipient */\n        bytes calldata, /* schema */\n        bytes calldata data,\n        uint256, /* expirationTime */\n        address /* msgSender */\n    ) external payable virtual override returns (bool) {\n        // Verifies that the data is either 0 or 1.\n        return data.length == 1 && (data[0] == \"\\x00\" || data[0] == \"\\x01\");\n    }\n}\n"
    },
    "contracts/tests/resolvers/TestASAttesterResolver.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../../EAS/TellerASResolver.sol\";\n\n/**\n * @title A sample AS resolver that checks whether the attestation is from a specific attester.\n */\ncontract TestASAttesterResolver is TellerASResolver {\n    address private immutable _targetAttester;\n\n    constructor(address targetAttester) {\n        _targetAttester = targetAttester;\n    }\n\n    function resolve(\n        address, /* recipient */\n        bytes calldata, /* schema */\n        bytes calldata, /* data */\n        uint256, /* expirationTime */\n        address msgSender\n    ) external payable virtual override returns (bool) {\n        return msgSender == _targetAttester;\n    }\n}\n"
    },
    "contracts/EAS/TellerASRegistry.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../Types.sol\";\nimport \"../interfaces/IASRegistry.sol\";\nimport \"../interfaces/IASResolver.sol\";\n\n/**\n * @title The global AS registry.\n */\ncontract TellerASRegistry is IASRegistry {\n    error AlreadyExists();\n\n    string public constant VERSION = \"0.8\";\n\n    // The global mapping between AS records and their IDs.\n    mapping(bytes32 => ASRecord) private _registry;\n\n    // The global counter for the total number of attestations.\n    uint256 private _asCount;\n\n    /**\n     * @inheritdoc IASRegistry\n     */\n    function register(bytes calldata schema, IASResolver resolver)\n        external\n        override\n        returns (bytes32)\n    {\n        uint256 index = ++_asCount;\n\n        ASRecord memory asRecord = ASRecord({\n            uuid: EMPTY_UUID,\n            index: index,\n            schema: schema,\n            resolver: resolver\n        });\n\n        bytes32 uuid = _getUUID(asRecord);\n        if (_registry[uuid].uuid != EMPTY_UUID) {\n            revert AlreadyExists();\n        }\n\n        asRecord.uuid = uuid;\n        _registry[uuid] = asRecord;\n\n        emit Registered(uuid, index, schema, resolver, msg.sender);\n\n        return uuid;\n    }\n\n    /**\n     * @inheritdoc IASRegistry\n     */\n    function getAS(bytes32 uuid)\n        external\n        view\n        override\n        returns (ASRecord memory)\n    {\n        return _registry[uuid];\n    }\n\n    /**\n     * @inheritdoc IASRegistry\n     */\n    function getASCount() external view override returns (uint256) {\n        return _asCount;\n    }\n\n    /**\n     * @dev Calculates a UUID for a given AS.\n     *\n     * @param asRecord The input AS.\n     *\n     * @return AS UUID.\n     */\n    function _getUUID(ASRecord memory asRecord) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(asRecord.schema, asRecord.resolver));\n    }\n}\n"
    },
    "contracts/EAS/TellerASEIP712Verifier.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\nimport \"../interfaces/IEASEIP712Verifier.sol\";\n\n/**\n * @title EIP712 typed signatures verifier for EAS delegated attestations.\n */\ncontract TellerASEIP712Verifier is IEASEIP712Verifier {\n    error InvalidSignature();\n\n    string public constant VERSION = \"0.8\";\n\n    // EIP712 domain separator, making signatures from different domains incompatible.\n    bytes32 public immutable DOMAIN_SEPARATOR; // solhint-disable-line var-name-mixedcase\n\n    // The hash of the data type used to relay calls to the attest function. It's the value of\n    // keccak256(\"Attest(address recipient,bytes32 schema,uint256 expirationTime,bytes32 refUUID,bytes data,uint256 nonce)\").\n    bytes32 public constant ATTEST_TYPEHASH =\n        0x39c0608dd995a3a25bfecb0fffe6801a81bae611d94438af988caa522d9d1476;\n\n    // The hash of the data type used to relay calls to the revoke function. It's the value of\n    // keccak256(\"Revoke(bytes32 uuid,uint256 nonce)\").\n    bytes32 public constant REVOKE_TYPEHASH =\n        0xbae0931f3a99efd1b97c2f5b6b6e79d16418246b5055d64757e16de5ad11a8ab;\n\n    // Replay protection nonces.\n    mapping(address => uint256) private _nonces;\n\n    /**\n     * @dev Creates a new EIP712Verifier instance.\n     */\n    constructor() {\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(\"EAS\")),\n                keccak256(bytes(VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @inheritdoc IEASEIP712Verifier\n     */\n    function getNonce(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _nonces[account];\n    }\n\n    /**\n     * @inheritdoc IEASEIP712Verifier\n     */\n    function attest(\n        address recipient,\n        bytes32 schema,\n        uint256 expirationTime,\n        bytes32 refUUID,\n        bytes calldata data,\n        address attester,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        ATTEST_TYPEHASH,\n                        recipient,\n                        schema,\n                        expirationTime,\n                        refUUID,\n                        keccak256(data),\n                        _nonces[attester]++\n                    )\n                )\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        if (recoveredAddress == address(0) || recoveredAddress != attester) {\n            revert InvalidSignature();\n        }\n    }\n\n    /**\n     * @inheritdoc IEASEIP712Verifier\n     */\n    function revoke(\n        bytes32 uuid,\n        address attester,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(REVOKE_TYPEHASH, uuid, _nonces[attester]++)\n                )\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        if (recoveredAddress == address(0) || recoveredAddress != attester) {\n            revert InvalidSignature();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}